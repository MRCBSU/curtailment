coeffs.p0 <- coeffs.p0[1:max(min(r+C+1, n+1), minstop+1), 1:n]
pascal.t <- pascal.t[1:max(min(r+C+1, n+1), minstop+1), ]
final.probs.mat <- pascal.t*coeffs
final.probs.mat.p0 <- pascal.t*coeffs.p0
##### Now find the terminal points: m must be a multiple of C, and CP must be 1 or 0:
##### SUCCESS:
## Only loop over rows that contain CP=1:
#rows.with.cp1 <- which(apply(mat, 1, function(x) {any(x==1, na.rm = T)}))
rows.with.cp1 <- which(rowSums(mat==1, na.rm = T)>0)
m.success <- NULL
Sm.success <- NULL
prob.success <- NULL
prob.success.p0 <- NULL
#
for(i in rows.with.cp1){
for(j in interims[interims >= i-1]){ # condition ensures Sm <= m
if(mat[i,j]==1){
m.success <- c(m.success, j)
Sm.success <- c(Sm.success, i-1)
prob.success <- c(prob.success, final.probs.mat[i, j])
prob.success.p0 <- c(prob.success.p0, final.probs.mat.p0[i, j])
}
}
}
success <- data.frame(Sm=Sm.success, m=m.success, prob=prob.success, success=rep("Success", length(m.success)))
# CAN FIND POWER AND TYPE I ERROR AT THIS POINT.
# IF TOO LOW OR HIGH, STOP AND MOVE ON:
pwr <- sum(prob.success)
typeI <- sum(prob.success.p0)
if(pwr < power | typeI > alpha)
{
return(c(n, r, C, typeI, pwr,  NA, NA, thetaF, thetaE, NA, minstop))
}
##### FAILURE:
submat <- mat[1:(r+1), ]
first.zero.in.row <- apply(submat, 1, function(x) match(0, x))
m.fail <- as.numeric(first.zero.in.row)
Sm.fail <- as.numeric(names(first.zero.in.row))
fail.deets.prob <- numeric(length(m.fail))
fail.deets.prob.p0 <- numeric(length(m.fail))
for(i in 1:length(m.fail)){
fail.deets.prob[i] <- final.probs.mat[Sm.fail[i]+1, m.fail[i]]
fail.deets.prob.p0[i] <- final.probs.mat.p0[Sm.fail[i]+1, m.fail[i]]
}
# Make df of terminal points:
fail.deets <- data.frame(Sm=Sm.fail, m=m.fail, prob=fail.deets.prob, success=rep("Fail", length(Sm.fail)))
tp <- rbind(fail.deets, success)
tp <- tp[tp$prob>0, ]
sample.size.expd.fail <- sum(m.fail*fail.deets.prob)
sample.size.expd.p0.fail <- sum(m.fail*fail.deets.prob.p0)
sample.size.expd.success <- sum(m.success*prob.success)
sample.size.expd.p0.success <- sum(m.success*prob.success.p0)
sample.size.expd <- sample.size.expd.fail + sample.size.expd.success
sample.size.expd.p0 <- sample.size.expd.p0.fail + sample.size.expd.p0.success
############ EFFECTIVE N. THE "EFFECTIVE N" OF A STUDY IS THE "REAL" MAXIMUM SAMPLE SIZE
######## The point is where every Sm for a given m equals zero or one is necessarily where a trial stops
cp.colsums <- colSums(mat==0, na.rm = T) + colSums(mat==1, na.rm = T)
possible.cps <- colSums(!is.na(mat))
effective.n <- min(which(cp.colsums==possible.cps))
return.vec <- c(n, r, C, typeI, pwr, sample.size.expd.p0, sample.size.expd, thetaF, thetaE, effective.n, minstop)
if(return.tps==TRUE){
return.list <- list(ocs=return.vec, tp=tp)
return(return.list)
}
return.vec
}
##################### FUNCTION findDesignOCs
# n = sample size
# r = stopping boundary
# C = Block size
# thetaF = theta_F (lower threshold)
# thetaE = theta_E (upper threshold)
# mat = Conditional Power matrix (before application of stochastic curtailment)
# alpha = significance level
# power = required power (1-beta)
# coeffs.p0 = coefficients under H0
# coeffs = coefficients under H1
findDesignOCs <- function(n, r, C, thetaF, thetaE, mat, power, alpha, coeffs, coeffs.p0, p0, p1, return.tps=FALSE, minstop){
q0 <- 1-p0
q1 <- 1-p1
interims <- seq(minstop, n, by=C)
pat.cols <- rev(interims)[-1]
# Amend CP matrix, rounding up to 1 when CP>theta_1 and rounding down to 0 when CP<thetaF:
const <- choose(C,0:C)*p1^(0:C)*q1^(C:0)
for(i in (r+1):1){
for(j in pat.cols){  # Only look every C patients (no need to look at final col)
if(i-1<=j){ # Condition: Sm<=m
newcp <- sum(const*mat[i:(i+C), j+C])
if(newcp > thetaE){
mat[i,j] <- 1
}else{
if(newcp < thetaF){
mat[i,j] <- 0
}else{
mat[i,j] <- newcp
}
}
}
}
}
###### STOP if design is pointless, i.e either failure or success is not possible:
# IF DESIGN GUARANTEES FAILURE (==0) or SUCCESS (==2) at n=minstop:
#first.cohort <- sum(mat[,C], na.rm = T)
first.cohort <- sum(mat[,minstop], na.rm = T)
if(first.cohort==minstop+1){
return(c(n, r, C, 1, 1,  NA, NA, thetaF, thetaE, NA, minstop))
}
if(first.cohort==0){
return(c(n, r, C, 0, 0,  NA, NA, thetaF, thetaE, NA, minstop))
}
############# Number of paths to each point:
pascal.list <- list(c(1,1))
if(C>1 | minstop>1){
for(i in 2:minstop){
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
}
for(i in min(minstop+1,n):n){ # Adding min() in case of stages=1, i.e. cohort size C=n.
if(i %% C == 1 || C==1){
column <- as.numeric(mat[!is.na(mat[,i-1]), i-1])
newnew <- pascal.list[[i-1]]
CPzero.or.one <- which(column==0 | column==1)
newnew[CPzero.or.one] <- 0
pascal.list[[i]] <- c(0, newnew) + c(newnew, 0)
} else {
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
}
for(i in 1:length(pascal.list)){
pascal.list[[i]] <- c(pascal.list[[i]], rep(0, length(pascal.list)+1-length(pascal.list[[i]])))
}
browser()
pascal.t <- t(do.call(rbind, args = pascal.list))
pascal.t <- pascal.t[1:max(min(r+C+1, n+1), minstop+1), ] # Adding min() in case of stages=1, i.e. cohort size C=n.
# Multiply the two matrices (A and p^b * q^c). This gives the probability of reaching each point:
# Note: Only need the first r+C+1 (or first minstop+1) rows -- no other rows can be reached.
coeffs <- coeffs[1:max(min(r+C+1, n+1), minstop+1), 1:n]
coeffs.p0 <- coeffs.p0[1:max(min(r+C+1, n+1), minstop+1), 1:n]
pascal.t <- pascal.t[1:max(min(r+C+1, n+1), minstop+1), ]
final.probs.mat <- pascal.t*coeffs
final.probs.mat.p0 <- pascal.t*coeffs.p0
##### Now find the terminal points: m must be a multiple of C, and CP must be 1 or 0:
##### SUCCESS:
## Only loop over rows that contain CP=1:
#rows.with.cp1 <- which(apply(mat, 1, function(x) {any(x==1, na.rm = T)}))
rows.with.cp1 <- which(rowSums(mat==1, na.rm = T)>0)
m.success <- NULL
Sm.success <- NULL
prob.success <- NULL
prob.success.p0 <- NULL
#
for(i in rows.with.cp1){
for(j in interims[interims >= i-1]){ # condition ensures Sm <= m
if(mat[i,j]==1){
m.success <- c(m.success, j)
Sm.success <- c(Sm.success, i-1)
prob.success <- c(prob.success, final.probs.mat[i, j])
prob.success.p0 <- c(prob.success.p0, final.probs.mat.p0[i, j])
}
}
}
success <- data.frame(Sm=Sm.success, m=m.success, prob=prob.success, success=rep("Success", length(m.success)))
# CAN FIND POWER AND TYPE I ERROR AT THIS POINT.
# IF TOO LOW OR HIGH, STOP AND MOVE ON:
pwr <- sum(prob.success)
typeI <- sum(prob.success.p0)
if(pwr < power | typeI > alpha)
{
return(c(n, r, C, typeI, pwr,  NA, NA, thetaF, thetaE, NA, minstop))
}
##### FAILURE:
submat <- mat[1:(r+1), ]
first.zero.in.row <- apply(submat, 1, function(x) match(0, x))
m.fail <- as.numeric(first.zero.in.row)
Sm.fail <- as.numeric(names(first.zero.in.row))
fail.deets.prob <- numeric(length(m.fail))
fail.deets.prob.p0 <- numeric(length(m.fail))
for(i in 1:length(m.fail)){
fail.deets.prob[i] <- final.probs.mat[Sm.fail[i]+1, m.fail[i]]
fail.deets.prob.p0[i] <- final.probs.mat.p0[Sm.fail[i]+1, m.fail[i]]
}
# Make df of terminal points:
fail.deets <- data.frame(Sm=Sm.fail, m=m.fail, prob=fail.deets.prob, success=rep("Fail", length(Sm.fail)))
tp <- rbind(fail.deets, success)
tp <- tp[tp$prob>0, ]
sample.size.expd.fail <- sum(m.fail*fail.deets.prob)
sample.size.expd.p0.fail <- sum(m.fail*fail.deets.prob.p0)
sample.size.expd.success <- sum(m.success*prob.success)
sample.size.expd.p0.success <- sum(m.success*prob.success.p0)
sample.size.expd <- sample.size.expd.fail + sample.size.expd.success
sample.size.expd.p0 <- sample.size.expd.p0.fail + sample.size.expd.p0.success
############ EFFECTIVE N. THE "EFFECTIVE N" OF A STUDY IS THE "REAL" MAXIMUM SAMPLE SIZE
######## The point is where every Sm for a given m equals zero or one is necessarily where a trial stops
cp.colsums <- colSums(mat==0, na.rm = T) + colSums(mat==1, na.rm = T)
possible.cps <- colSums(!is.na(mat))
effective.n <- min(which(cp.colsums==possible.cps))
return.vec <- c(n, r, C, typeI, pwr, sample.size.expd.p0, sample.size.expd, thetaF, thetaE, effective.n, minstop)
if(return.tps==TRUE){
return.list <- list(ocs=return.vec, tp=tp)
return(return.list)
}
return.vec
}
createPlotAndBounds(des = des.jun$all.des, des.input = des.jun$input, rownum = 1, xmax = 14, ymax = 14)
pascal.t
success
##################### FUNCTION findDesignOCs
# n = sample size
# r = stopping boundary
# C = Block size
# thetaF = theta_F (lower threshold)
# thetaE = theta_E (upper threshold)
# mat = Conditional Power matrix (before application of stochastic curtailment)
# alpha = significance level
# power = required power (1-beta)
# coeffs.p0 = coefficients under H0
# coeffs = coefficients under H1
findDesignOCs <- function(n, r, C, thetaF, thetaE, mat, power, alpha, coeffs, coeffs.p0, p0, p1, return.tps=FALSE, minstop){
q0 <- 1-p0
q1 <- 1-p1
interims <- seq(minstop, n, by=C)
pat.cols <- rev(interims)[-1]
# Amend CP matrix, rounding up to 1 when CP>theta_1 and rounding down to 0 when CP<thetaF:
const <- choose(C,0:C)*p1^(0:C)*q1^(C:0)
for(i in (r+1):1){
for(j in pat.cols){  # Only look every C patients (no need to look at final col)
if(i-1<=j){ # Condition: Sm<=m
newcp <- sum(const*mat[i:(i+C), j+C])
if(newcp > thetaE){
mat[i,j] <- 1
}else{
if(newcp < thetaF){
mat[i,j] <- 0
}else{
mat[i,j] <- newcp
}
}
}
}
}
###### STOP if design is pointless, i.e either failure or success is not possible:
# IF DESIGN GUARANTEES FAILURE (==0) or SUCCESS (==2) at n=minstop:
#first.cohort <- sum(mat[,C], na.rm = T)
first.cohort <- sum(mat[,minstop], na.rm = T)
if(first.cohort==minstop+1){
return(c(n, r, C, 1, 1,  NA, NA, thetaF, thetaE, NA, minstop))
}
if(first.cohort==0){
return(c(n, r, C, 0, 0,  NA, NA, thetaF, thetaE, NA, minstop))
}
############# Number of paths to each point:
pascal.list <- list(c(1,1))
if(C>1 | minstop>1){
for(i in 2:minstop){
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
}
for(i in min(minstop+1,n):n){ # Adding min() in case of stages=1, i.e. cohort size C=n.
if(i %% C == 1 || C==1){
column <- as.numeric(mat[!is.na(mat[,i-1]), i-1])
newnew <- pascal.list[[i-1]]
CPzero.or.one <- which(column==0 | column==1)
newnew[CPzero.or.one] <- 0
pascal.list[[i]] <- c(0, newnew) + c(newnew, 0)
} else {
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
}
for(i in 1:length(pascal.list)){
pascal.list[[i]] <- c(pascal.list[[i]], rep(0, length(pascal.list)+1-length(pascal.list[[i]])))
}
pascal.t <- t(do.call(rbind, args = pascal.list))
pascal.t <- pascal.t[1:max(min(r+C+1, n+1), minstop+1), ] # Adding min() in case of stages=1, i.e. cohort size C=n.
# Multiply the two matrices (A and p^b * q^c). This gives the probability of reaching each point:
# Note: Only need the first r+C+1 (or first minstop+1) rows -- no other rows can be reached.
coeffs <- coeffs[1:max(min(r+C+1, n+1), minstop+1), 1:n]
coeffs.p0 <- coeffs.p0[1:max(min(r+C+1, n+1), minstop+1), 1:n]
pascal.t <- pascal.t[1:max(min(r+C+1, n+1), minstop+1), ]
final.probs.mat <- pascal.t*coeffs
final.probs.mat.p0 <- pascal.t*coeffs.p0
##### Now find the terminal points: m must be a multiple of C, and CP must be 1 or 0:
##### SUCCESS:
## Only loop over rows that contain CP=1:
#rows.with.cp1 <- which(apply(mat, 1, function(x) {any(x==1, na.rm = T)}))
rows.with.cp1 <- which(rowSums(mat==1, na.rm = T)>0)
m.success <- NULL
Sm.success <- NULL
prob.success <- NULL
prob.success.p0 <- NULL
#
for(i in rows.with.cp1){
for(j in interims[interims >= i-1]){ # condition ensures Sm <= m
if(mat[i,j]==1){
m.success <- c(m.success, j)
Sm.success <- c(Sm.success, i-1)
prob.success <- c(prob.success, final.probs.mat[i, j])
prob.success.p0 <- c(prob.success.p0, final.probs.mat.p0[i, j])
}
}
}
success <- data.frame(Sm=Sm.success, m=m.success, prob=prob.success, success=rep("Success", length(m.success)))
# CAN FIND POWER AND TYPE I ERROR AT THIS POINT.
# IF TOO LOW OR HIGH, STOP AND MOVE ON:
pwr <- sum(prob.success)
typeI <- sum(prob.success.p0)
if(pwr < power | typeI > alpha)
{
return(c(n, r, C, typeI, pwr,  NA, NA, thetaF, thetaE, NA, minstop))
}
##### FAILURE:
submat <- mat[1:(r+1), ]
first.zero.in.row <- apply(submat, 1, function(x) match(0, x))
m.fail <- as.numeric(first.zero.in.row)
Sm.fail <- as.numeric(names(first.zero.in.row))
fail.deets.prob <- numeric(length(m.fail))
fail.deets.prob.p0 <- numeric(length(m.fail))
for(i in 1:length(m.fail)){
fail.deets.prob[i] <- final.probs.mat[Sm.fail[i]+1, m.fail[i]]
fail.deets.prob.p0[i] <- final.probs.mat.p0[Sm.fail[i]+1, m.fail[i]]
}
# Make df of terminal points:
fail.deets <- data.frame(Sm=Sm.fail, m=m.fail, prob=fail.deets.prob, success=rep("Fail", length(Sm.fail)))
tp <- rbind(fail.deets, success)
tp <- tp[tp$prob>0, ]
sample.size.expd.fail <- sum(m.fail*fail.deets.prob)
sample.size.expd.p0.fail <- sum(m.fail*fail.deets.prob.p0)
sample.size.expd.success <- sum(m.success*prob.success)
sample.size.expd.p0.success <- sum(m.success*prob.success.p0)
sample.size.expd <- sample.size.expd.fail + sample.size.expd.success
sample.size.expd.p0 <- sample.size.expd.p0.fail + sample.size.expd.p0.success
############ EFFECTIVE N. THE "EFFECTIVE N" OF A STUDY IS THE "REAL" MAXIMUM SAMPLE SIZE
######## The point is where every Sm for a given m equals zero or one is necessarily where a trial stops
cp.colsums <- colSums(mat==0, na.rm = T) + colSums(mat==1, na.rm = T)
possible.cps <- colSums(!is.na(mat))
effective.n <- min(which(cp.colsums==possible.cps))
return.vec <- c(n, r, C, typeI, pwr, sample.size.expd.p0, sample.size.expd, thetaF, thetaE, effective.n, minstop)
if(return.tps==TRUE){
return.list <- list(ocs=return.vec, tp=tp)
return(return.list)
}
return.vec
}
undebug(createPlotAndBounds)
createPlotAndBounds <- function(des, des.input, rownum, xmax, ymax){
m <- Sm <- decision <- analysis <- NULL
rownum <- as.numeric(rownum)
des <- as.data.frame(t(des[rownum, ]))
coef.list <- findCoeffs(n=des$n, p0 = des.input$p0, p1 = des.input$p1)
matt <- findCPmatrix(n=des$n, r=des$r, Csize=des$C, p0=des.input$p0, p1=des.input$p1, minstop=des.input$minstop) # uncurtailed matrix
findo <- findDesignOCs(n=des$n, r = des$r, C=des$C, thetaF = des$thetaF, thetaE = des$thetaE, p1 = des.input$p1, p0 = des.input$p0, alpha = des.input$alpha, power = des.input$power,
return.tps = TRUE, coeffs = coef.list$coeffs, coeffs.p0 = coef.list$coeffs.p0, mat=matt, minstop=des$eff.minstop)
tp.success <- findo$tp[findo$tp$success=="Success", ]
# Order by Sm (though this should already be the case):
tp.success <- tp.success[order(tp.success$Sm),]
tp.success.unneeded <- tp.success[duplicated(tp.success$m), ]
tp.fail <- findo$tp[findo$tp$success=="Fail", ]
coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
# for(i in 1:nrow(tp.success.unneeded)){
#   unneeded.success.index <- diag.df$Sm==tp.success.unneeded$Sm[i] & diag.df$m==tp.success.unneeded$m[i]
#   diag.df$decision[unneeded.success.index] <- NA
# }
tp.success.unique.m <- tp.success[!duplicated(tp.success$m), ]
stop.bounds <- data.frame(m=seq(from=des$C, to=des$n, by=des$C),
success=Inf,
fail=-Inf)
stop.bounds$success[match(tp.success.unique.m$m, stop.bounds$m)] <- tp.success.unique.m$Sm
stop.bounds$fail[match(tp.fail$m, stop.bounds$m)] <- tp.fail$Sm
# Actual number of stages:
des$stage <- sum(!is.infinite(stop.bounds$success) | !is.infinite(stop.bounds$fail))
# Add shading:
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
stop.index <- diag.df.subset$m %in% unique(findo$tp$m)
diag.df.subset$analysis[stop.index] <- "Yes"
plot.title <- "Stopping boundaries"
sub.text1 <- paste("Max no. of analyses: ", des$stage, ". Max(N): ", des$n, ". ESS(p", sep="")
sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
sub.text3 <- paste("):", round(des$Ess, 1), sep="")
plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
xbreaks <- seq(from=des$C, to=des$n, by=des$C)
if(!is.null(xmax)){
diagram <- diagram +
expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
expand_limits(y=ymax)
}
#print(diagram)
diagram <- diagram +
scale_x_continuous(breaks=xbreaks)+
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
createPlotAndBounds(des = des.jun$all.des, des.input = des.jun$input, rownum = 1, xmax = 14, ymax = 14)
devtools::load_all()
rm(list = c("createPlotAndBounds", "findCPmatrix", "findDesignOCs"))
devtools::load_all()
des.jun <- singlearmDesign(nmin=12,
nmax=14,
C=2,
p0=0.05,
p1=0.3,
alpha=0.05,
power=0.8,
minstop=6,
minthetaE = 0.9)
createPlotAndBounds(des = des.jun$all.des, des.input = des.jun$input, rownum = 1, xmax = 14, ymax = 14)
createPlotAndBounds(des = des.jun$all.des, des.input = des.jun$input, rownum = 1, xmax = 14, ymax = 6)
des.jun <- singlearmDesign(nmin=12,
nmax=15,
C=3,
p0=0.05,
p1=0.3,
alpha=0.05,
power=0.8,
minstop=6,
minthetaE = 0.9)
des.jun
drawDiagram(des.jun)
find2stageDesigns(nmin = 10, nmax = 16, p0 = 0.05, p1 = 0.3, alpha = 0.05, power = 0.8, benefit = F)
usethis::proj_sitrep()
devtools::load_all()
usethis::proj_sitrep()
usethis::proj_get()
usethis::proj_sitrep()
des.jun <- singlearmDesign(nmin=12,
nmax=15,
C=3,
p0=0.05,
p1=0.3,
alpha=0.05,
power=0.8,
minstop=6,
minthetaE = 0.9)
drawDiagram(des.jun)
createPlotAndBounds(des = des.jun$all.des, des.input = des.jun$input, rownum = 1, xmax = 14, ymax = 6)
n.all <- singlearmDesign(nmin=14,
nmax=16,
C=2:4,
p0=0.05,
p1=0.3,
alpha=0.05,
power=0.8,
minstop=6,
minthetaE=0.9)
n.all
drawDiagram(n.all, 3)
drawDiagram(n.all, 2)
drawDiagram(n.all, 1)
n15 <- singlearmDesign(nmin=15,
nmax=15,
C=3,
p0=0.05,
p1=0.3,
alpha=0.05,
power=0.8,
minstop=5,
minthetaE=0.9)
n15
drawDiagram(n15)
debug(createPlotAndBounds)
n15
createPlotAndBounds(des = n15$all.des, des.input = n15$input, rownum = 1, xmax = 14, ymax = 6)
matt
findo
minstop
des.input$minstop
undebug(createPlotAndBounds)
n15 <- singlearmDesign(nmin=15,
nmax=15,
C=3,
p0=0.05,
p1=0.3,
alpha=0.05,
power=0.8,
minstop=6,
minthetaE=0.9)
n15
drawDiagram(n15)
