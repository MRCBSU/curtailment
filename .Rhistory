rho.vec=0.1)
a1
a2
a2 <- findCPloserDes(nsims=10^4,
K=2,
vars=c(1,1),
delta0=c(0.1, -1000),
delta1=c(0.4, 0.4),
alpha.k=0.05,
alpha.combine=TRUE,
always.drop=FALSE,
seed=7,
cp.l=0.3,
cp.u=1,
n.init=60,
power=0.8,
n.max=100,
rho.vec=0.1)
install.packages("dplyr")
.libPaths()
new <- c("\\\\bliss-03-nfs/homes/martin/R_packages", .libPaths())
new
.libPaths(new)
.libPaths()
install.packages("dplyr")
new <- c("H:/martin/R_package_library", .libPaths())
.libPaths(new)
new
install.packages("dplyr")
.libPaths()
new
.libPaths(new)
.libPaths()
.libPaths(new)
.libPaths()
here::here()
new2 <- "H:/martin/R_package_library"
new2
.libPaths(new2)
.libPaths()
?.libPaths
.libPaths(new2)
.libPaths()
new
.libPaths(new)
.libPaths()
new <- c("H:/R_package_library", .libPaths())
.libPaths(new)
.libPaths()
.libPaths()
install.packages("dplyr")
devtools::install_github("martinlaw/curtailment")
library(curtailment)
new <- c("H:/R_package_library", .libPaths())
.libPaths(new)
#devtools::install_github("martinlaw/curtailment")
#library(curtailment)
install.packages("xfun")
new <- c("H:/R_package_library", .libPaths())
.libPaths(new)
#devtools::install_github("martinlaw/curtailment")
#library(curtailment)
install.packages("xfun")
library(xfun)
?xfun
?valid_syntax
install.packages("xfun")
new <- c("H:/R_package_library", .libPaths())
.libPaths(new)
#devtools::install_github("martinlaw/curtailment")
#library(curtailment)
install.packages("xfun")
new
.libPaths(new)
new <- c("../../../../H:/R_package_library")
.libPaths(new)
#devtools::install_github("martinlaw/curtailment")
#library(curtailment)
install.packages("xfun")
new <- c("H:/R_package_library", .libPaths())
.libPaths()
.libPaths(new)
.libPaths()
#devtools::install_github("martinlaw/curtailment")
#library(curtailment)
install.packages("xfun")
install.packages("rmarkdown")
install.packages("H:/rmarkdown_2.9.zip", repos = NULL, type = "win.binary")
new <- c("H:/R_package_library", .libPaths())
.libPaths(new)
.libPaths()
install.packages("//bliss-03-nfs/homes/martin/xfun_0.24.zip", repos = NULL, type = "win.binary")
remove.packages("xfun", lib="\\bliss-03-nfs/homes/martin/Documents/R/win-library/3.6")
library(xfun)
install.packages("//bliss-03-nfs/homes/martin/xfun_0.24.zip", repos = NULL, type = "win.binary")
library(xfun)
library(rmarkdown)
setwd("H:/Nof1/Bayesian-bandit-adaptive-n-of-1-master/Bayesian-bandit-adaptive-n-of-1-master")
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 4,             # number of Markov chains
warmup = 4000,          # number of warmup iterations per chain
iter = 6000,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
source("AGGBAN_run.R")
source("INDBAN_run.R")
source("B_BAN_run.R")
source("FRN_run.R")
#population parameters
set.seed(2356)
tru.b.mu = c(7,-1) #population mean
tru.b.sig = c(1,3) #standard deviation suggesting between-patient variation
tru.y.sig = 2 #within-patient deviance
J = 3 #number of patients
nperiod = 4 #number of periods (two per cycle)
nobv = 2 #number of observations per patient
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 2,             # number of Markov chains
warmup = 40,          # number of warmup iterations per chain
iter = 60,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
#indiv parameters
b0 = rnorm(J,tru.b.mu[1],tru.b.sig[1])
b1 = rnorm(J,tru.b.mu[2],tru.b.sig[2])
b = cbind(b0,b1)
trup = c(tru.b.mu,tru.b.sig,tru.y.sig,b0,b1)
set.seed(NULL) #undo seed setting
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
install.packages("rstan", type = "win.binary", dependencies = TRUE)
install.packages("rstan", type = "win.binary", dependencies = TRUE)
install.packages( "https://win-builder.r-project.org/9256KcZ01L9C/StanHeaders_2.19.2.zip", repos = NULL, type = "win.binary")
#indiv parameters
b0 = rnorm(J,tru.b.mu[1],tru.b.sig[1])
b1 = rnorm(J,tru.b.mu[2],tru.b.sig[2])
b = cbind(b0,b1)
trup = c(tru.b.mu,tru.b.sig,tru.y.sig,b0,b1)
set.seed(NULL) #undo seed setting
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 2,             # number of Markov chains
warmup = 40,          # number of warmup iterations per chain
iter = 60,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
J = 3 #number of patients
nperiod = 4 #number of periods (two per cycle)
nobv = 2 #number of observations per patient
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
install.packages(c("rstan","StanHeaders"),type="source")
install.packages(c("rstan", "StanHeaders"), type = "source")
install.packages(c("rstan","StanHeaders"),type="source")
install.packages("StanHeaders", type="source")
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 2,             # number of Markov chains
warmup = 40,          # number of warmup iterations per chain
iter = 60,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
#indiv parameters
b0 = rnorm(J,tru.b.mu[1],tru.b.sig[1])
b1 = rnorm(J,tru.b.mu[2],tru.b.sig[2])
b = cbind(b0,b1)
trup = c(tru.b.mu,tru.b.sig,tru.y.sig,b0,b1)
set.seed(NULL) #undo seed setting
J = 3 #number of patients
nperiod = 4 #number of periods (two per cycle)
nobv = 2 #number of observations per patient
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
install.packages("RcppEigen")
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
remove.packages("StanHeaders")
install.packages("RcppParallel")
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
setwd("H:/")
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars.win")
if (!file.exists(M)) file.create(M)
cat("\n CXX14FLAGS += -mtune=native -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2",
file = M, sep = "\n", append = FALSE)
devtools::install_version("StanHeaders", version="2.19.0")
Sys.getenv("BINPREF")
Sys.which("make")
install.packages("jsonlite", type = "source")
?install.packages
?install.packages
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
remove.packages("StanHeaders")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
setwd("H:/")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
install.packages("jsonlite", type = "source")
remove.packages("rstan")
remove.packages("StanHeaders")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install_cmdstan()
path.expand()
path.expand("~")
R.home(component="home")
14.4*33
1000/33
4*33
300*4
600*12
1/0.997
0.003/1
1/0.003
333*600000
setwd("~/R_packages/curtailment")
library(devtools)
load_all()
