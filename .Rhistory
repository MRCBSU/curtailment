sample.size.expd.p0.success <- sum(m.success*prob.success.p0)
sample.size.expd <- sample.size.expd.fail + sample.size.expd.success
sample.size.expd.p0 <- sample.size.expd.p0.fail + sample.size.expd.p0.success
############ EFFECTIVE N. THE "EFFECTIVE N" OF A STUDY IS THE "REAL" MAXIMUM SAMPLE SIZE
######## The point is where every Sm for a given m equals zero or one is necessarily where a trial stops
#cp.colsums <- apply(mat, 2, function(x) { sum(x==0, na.rm=TRUE)+sum(x==1, na.rm=TRUE)} ) # Sum the CP values that equal zero or one in each column
cp.colsums <- colSums(mat==0, na.rm = T) + colSums(mat==1, na.rm = T)
# possible.cps <- apply(mat, 2, function(x) {sum(!is.na(x))})
possible.cps <- colSums(!is.na(mat))
effective.n <- min(which(cp.colsums==possible.cps))
return.vec <- c(n, r, C, typeI, pwr, sample.size.expd.p0, sample.size.expd, thetaF, thetaE, effective.n)
if(return.tps==TRUE){
return.list <- list(ocs=return.vec, tp=tp)
return(return.list)
}
return.vec
}
library(curtailment)
findDesignOCs <- function(n, r, C, thetaF, thetaE, mat, power, alpha, coeffs, coeffs.p0, p0, p1, return.tps=FALSE){
q0 <- 1-p0
q1 <- 1-p1
interims <- seq(C, n, by=C)
pat.cols <- rev(interims)[-1]
# Amend CP matrix, rounding up to 1 when CP>theta_1 and rounding down to 0 when CP<thetaF:
const <- choose(C,0:C)*p1^(0:C)*q1^(C:0)
for(i in (r+1):1){
for(j in pat.cols){  # Only look every C patients (no need to look at final col)
if(i-1<=j){ # Condition: Sm<=m
newcp <- sum(const*mat[i:(i+C), j+C])
if(newcp > thetaE){
mat[i,j] <- 1
}else{
if(newcp < thetaF){
mat[i,j] <- 0
}else{
mat[i,j] <- newcp
}
# for(i in (r+1):1){
#   for(j in pat.cols){  # Only look every C patients (no need to look at final col)
#     if(i-1<=j){ # Condition: Sm<=m
#       newcp <- sum(choose(C,0:C)*p1^(0:C)*q1^(C:0)*mat[i:(i+C),j+C])
#       if(newcp > thetaE){
#         mat[i,j] <- 1
#       }else{
#         if(newcp < thetaF){
#           mat[i,j] <- 0
#         }else{
#         mat[i,j] <- newcp
#       }
#     }
#   }
# }
#if(abs(thetaF-0.352)<0.0001 & abs(thetaE-0.98823057)<0.0001) browser()
###### STOP if design is pointless, i.e either failure or success is not possible:
# IF DESIGN GUARANTEES FAILURE (==0) or SUCCESS (==2) at n=C:
first.cohort <- sum(mat[,C], na.rm = T)
if(first.cohort==C+1){
return(c(n, r, C, 1, 1,  NA, NA, thetaF, thetaE, NA))
}
if(first.cohort==0){
return(c(n, r, C, 0, 0,  NA, NA, thetaF, thetaE, NA))
}
############# Number of paths to each point:
pascal.list <- list(c(1,1))
if(C>1){
for(i in 2:C){
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
for(i in min(C+1,n):n){ # Adding min() in case of stages=1, i.e. cohort size C=n.
if(i %% C == 1 || C==1){
column <- as.numeric(mat[!is.na(mat[,i-1]), i-1])
newnew <- pascal.list[[i-1]]
CPzero.or.one <- which(column==0 | column==1)
newnew[CPzero.or.one] <- 0
pascal.list[[i]] <- c(0, newnew) + c(newnew, 0)
} else {
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
for(i in 1:length(pascal.list)){
pascal.list[[i]] <- c(pascal.list[[i]], rep(0, length(pascal.list)+1-length(pascal.list[[i]])))
}
pascal.t <- t(do.call(rbind, args = pascal.list))
pascal.t <- pascal.t[1:min(r+C+1, n+1), ] # Adding min() in case of stages=1, i.e. cohort size C=n.
# Multiply the two matrices (A and p^b * q^c). This gives the probability of reaching each point:
# Note: Only need the first r+C+1 rows -- no other rows can be reached.
coeffs <- coeffs[1:min(r+C+1, n+1), 1:n]
coeffs.p0 <- coeffs.p0[1:min(r+C+1, n+1), 1:n]
pascal.t <- pascal.t[1:min(r+C+1, n+1), ]
final.probs.mat <- pascal.t*coeffs
final.probs.mat.p0 <- pascal.t*coeffs.p0
browser()
##### Now find the terminal points: m must be a multiple of C, and CP must be 1 or 0:
##### SUCCESS:
## Only loop over rows that contain CP=1:
#rows.with.cp1 <- which(apply(mat, 1, function(x) {any(x==1, na.rm = T)}))
rows.with.cp1 <- which(rowSums(mat==1, na.rm = T)>0)
m.success <- NULL
Sm.success <- NULL
prob.success <- NULL
prob.success.p0 <- NULL
#
for(i in rows.with.cp1){
for(j in interims[interims >= i-1]){ # condition ensures Sm <= m
if(mat[i,j]==1){
m.success <- c(m.success, j)
Sm.success <- c(Sm.success, i-1)
prob.success <- c(prob.success, final.probs.mat[i, j])
prob.success.p0 <- c(prob.success.p0, final.probs.mat.p0[i, j])
}
# mat.equals.1 <- mat==1
# row.index.list <- alply(mat.equals.1[, interims], 2, which)
# # alply always returns a list, whereas apply returns a matrix when all cols have same number of results.
# row.index <- unlist(row.index.list)
# total.length <- unlist(lapply(row.index.list, length))
# m.success <- rep(interims, c(total.length))
# index <- cbind(row.index, m.success)
# for(i in 1:nrow(index)){
#   prob.success[i] <- final.probs.mat[index[i, 1], index[i, 2]]
#   prob.success.p0[i] <- final.probs.mat.p0[index[i, 1], index[i, 2]]
#   }
# prob.success <- apply(index, 1, function(x) final.probs.mat[x[1], x[2]])
# prob.success.p0 <- apply(index, 1, function(x) final.probs.mat.p0[x[1], x[2]])
success <- data.frame(Sm=Sm.success, m=m.success, prob=prob.success, success=rep("Success", length(m.success)))
#
# CAN FIND POWER AND TYPE I ERROR AT THIS POINT.
# IF TOO LOW OR HIGH, STOP AND MOVE ON:
#
# pwr <- sum(success[,"prob"])
# typeI <- sum(success[,"prob.p0"])
pwr <- sum(prob.success)
typeI <- sum(prob.success.p0)
if(pwr < power | typeI > alpha) # | pwr > power+tol | alpha < alpha-tol)
{
return(c(n, r, C, typeI, pwr,  NA, NA, thetaF, thetaE, NA))
}
##### FAILURE:
#first.zero.in.row <- apply(mat[1:(r+1),], 1, function(x) {which.max(x[interims]==0)})
submat <- mat[1:(r+1), interims]
first.zero.in.row <- apply(submat, 1, function(x) match(0, x))
m.fail <- C * as.numeric(first.zero.in.row)
Sm.fail <- as.numeric(names(first.zero.in.row))
#fail.deets <- data.frame(Sm=Sm.fail, m=m.fail)
#fail.deets$prob <- apply(fail.deets, 1, function(x) {final.probs.mat[x["Sm"]+1, x["m"]]})
#fail.deets$prob.p0 <- apply(fail.deets, 1, function(x) {final.probs.mat.p0[x["Sm"]+1, x["m"]]})
fail.deets.prob <- numeric(length(m.fail))
fail.deets.prob.p0 <- numeric(length(m.fail))
for(i in 1:length(m.fail)){
fail.deets.prob[i] <- final.probs.mat[Sm.fail[i]+1, m.fail[i]]
fail.deets.prob.p0[i] <- final.probs.mat.p0[Sm.fail[i]+1, m.fail[i]]
}
# Make df of terminal points:
fail.deets <- data.frame(Sm=Sm.fail, m=m.fail, prob=fail.deets.prob, success=rep("Fail", length(Sm.fail)))
tp <- rbind(fail.deets, success)
tp <- tp[tp$prob>0, ]
#sample.size.expd <- sum(output$m*output$prob)
#sample.size.expd.p0 <- sum(output$m*output$prob.p0)
#sample.size.expd.fail <- sum(fail.deets$m*fail.deets$prob)
#sample.size.expd.p0.fail <- sum(fail.deets$m*fail.deets$prob.p0)
sample.size.expd.fail <- sum(m.fail*fail.deets.prob)
sample.size.expd.p0.fail <- sum(m.fail*fail.deets.prob.p0)
sample.size.expd.success <- sum(m.success*prob.success)
sample.size.expd.p0.success <- sum(m.success*prob.success.p0)
sample.size.expd <- sample.size.expd.fail + sample.size.expd.success
sample.size.expd.p0 <- sample.size.expd.p0.fail + sample.size.expd.p0.success
############ EFFECTIVE N. THE "EFFECTIVE N" OF A STUDY IS THE "REAL" MAXIMUM SAMPLE SIZE
######## The point is where every Sm for a given m equals zero or one is necessarily where a trial stops
#cp.colsums <- apply(mat, 2, function(x) { sum(x==0, na.rm=TRUE)+sum(x==1, na.rm=TRUE)} ) # Sum the CP values that equal zero or one in each column
cp.colsums <- colSums(mat==0, na.rm = T) + colSums(mat==1, na.rm = T)
# possible.cps <- apply(mat, 2, function(x) {sum(!is.na(x))})
possible.cps <- colSums(!is.na(mat))
effective.n <- min(which(cp.colsums==possible.cps))
return.vec <- c(n, r, C, typeI, pwr, sample.size.expd.p0, sample.size.expd, thetaF, thetaE, effective.n)
if(return.tps==TRUE){
return.list <- list(ocs=return.vec, tp=tp)
return(return.list)
}
return.vec
}
# Find number of paths to terminal points:
n <- 52
nmax <- n
r <- 15
Csize <- 1
p0 <- 0.2
p1 <- 0.4
q0 <- 1-p0
q1 <- 1-p1
mat.list <- findCPmatrix(n=n, r=r, Csize=Csize, p0=p0, p1=p1)
mat.list <- curtailment:::findCPmatrix(n=n, r=r, Csize=Csize, p0=p0, p1=p1)
mat.list
##### Matrix of coefficients: Probability of a SINGLE path leading to each point:
coeffs <- matrix(NA, ncol=nmax, nrow=nmax+1)
coeffs.p0 <- coeffs
for(i in 1:(nmax+1)){
coeffs[i, ] <- p1^(i-1) * q1^((2-i):(2-i+nmax-1))
coeffs.p0[i, ] <- p0^(i-1) * q0^((2-i):(2-i+nmax-1))
}
coeffs
coeffs.p0
x <- findDesignOCs(n=52, r=15, C, thetaF=0.135, thetaE=0.996, mat=mat.list, power=0.9, alpha=0.05, coeffs=coeffs, coeffs.p0=coeffs.p0, p0=0.2, p1=0.4, return.tps=T)
x <- findDesignOCs(n=52, r=15, C=Csize, thetaF=0.135, thetaE=0.996, mat=mat.list, power=0.9, alpha=0.05, coeffs=coeffs, coeffs.p0=coeffs.p0, p0=0.2, p1=0.4, return.tps=T)
pascal.list
2^52
findDesignOCs <- function(n, r, C, thetaF, thetaE, mat, power, alpha, coeffs, coeffs.p0, p0, p1, return.tps=FALSE){
q0 <- 1-p0
q1 <- 1-p1
interims <- seq(C, n, by=C)
pat.cols <- rev(interims)[-1]
# Amend CP matrix, rounding up to 1 when CP>theta_1 and rounding down to 0 when CP<thetaF:
const <- choose(C,0:C)*p1^(0:C)*q1^(C:0)
for(i in (r+1):1){
for(j in pat.cols){  # Only look every C patients (no need to look at final col)
if(i-1<=j){ # Condition: Sm<=m
newcp <- sum(const*mat[i:(i+C), j+C])
if(newcp > thetaE){
mat[i,j] <- 1
}else{
if(newcp < thetaF){
mat[i,j] <- 0
}else{
mat[i,j] <- newcp
}
browser()
# for(i in (r+1):1){
#   for(j in pat.cols){  # Only look every C patients (no need to look at final col)
#     if(i-1<=j){ # Condition: Sm<=m
#       newcp <- sum(choose(C,0:C)*p1^(0:C)*q1^(C:0)*mat[i:(i+C),j+C])
#       if(newcp > thetaE){
#         mat[i,j] <- 1
#       }else{
#         if(newcp < thetaF){
#           mat[i,j] <- 0
#         }else{
#         mat[i,j] <- newcp
#       }
#     }
#   }
# }
#if(abs(thetaF-0.352)<0.0001 & abs(thetaE-0.98823057)<0.0001) browser()
###### STOP if design is pointless, i.e either failure or success is not possible:
# IF DESIGN GUARANTEES FAILURE (==0) or SUCCESS (==2) at n=C:
first.cohort <- sum(mat[,C], na.rm = T)
if(first.cohort==C+1){
return(c(n, r, C, 1, 1,  NA, NA, thetaF, thetaE, NA))
}
if(first.cohort==0){
return(c(n, r, C, 0, 0,  NA, NA, thetaF, thetaE, NA))
}
############# Number of paths to each point:
pascal.list <- list(c(1,1))
if(C>1){
for(i in 2:C){
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
for(i in min(C+1,n):n){ # Adding min() in case of stages=1, i.e. cohort size C=n.
if(i %% C == 1 || C==1){
column <- as.numeric(mat[!is.na(mat[,i-1]), i-1])
newnew <- pascal.list[[i-1]]
CPzero.or.one <- which(column==0 | column==1)
newnew[CPzero.or.one] <- 0
pascal.list[[i]] <- c(0, newnew) + c(newnew, 0)
} else {
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
for(i in 1:length(pascal.list)){
pascal.list[[i]] <- c(pascal.list[[i]], rep(0, length(pascal.list)+1-length(pascal.list[[i]])))
}
pascal.t <- t(do.call(rbind, args = pascal.list))
pascal.t <- pascal.t[1:min(r+C+1, n+1), ] # Adding min() in case of stages=1, i.e. cohort size C=n.
# Multiply the two matrices (A and p^b * q^c). This gives the probability of reaching each point:
# Note: Only need the first r+C+1 rows -- no other rows can be reached.
coeffs <- coeffs[1:min(r+C+1, n+1), 1:n]
coeffs.p0 <- coeffs.p0[1:min(r+C+1, n+1), 1:n]
pascal.t <- pascal.t[1:min(r+C+1, n+1), ]
final.probs.mat <- pascal.t*coeffs
final.probs.mat.p0 <- pascal.t*coeffs.p0
##### Now find the terminal points: m must be a multiple of C, and CP must be 1 or 0:
##### SUCCESS:
## Only loop over rows that contain CP=1:
#rows.with.cp1 <- which(apply(mat, 1, function(x) {any(x==1, na.rm = T)}))
rows.with.cp1 <- which(rowSums(mat==1, na.rm = T)>0)
m.success <- NULL
Sm.success <- NULL
prob.success <- NULL
prob.success.p0 <- NULL
#
for(i in rows.with.cp1){
for(j in interims[interims >= i-1]){ # condition ensures Sm <= m
if(mat[i,j]==1){
m.success <- c(m.success, j)
Sm.success <- c(Sm.success, i-1)
prob.success <- c(prob.success, final.probs.mat[i, j])
prob.success.p0 <- c(prob.success.p0, final.probs.mat.p0[i, j])
}
# mat.equals.1 <- mat==1
# row.index.list <- alply(mat.equals.1[, interims], 2, which)
# # alply always returns a list, whereas apply returns a matrix when all cols have same number of results.
# row.index <- unlist(row.index.list)
# total.length <- unlist(lapply(row.index.list, length))
# m.success <- rep(interims, c(total.length))
# index <- cbind(row.index, m.success)
# for(i in 1:nrow(index)){
#   prob.success[i] <- final.probs.mat[index[i, 1], index[i, 2]]
#   prob.success.p0[i] <- final.probs.mat.p0[index[i, 1], index[i, 2]]
#   }
# prob.success <- apply(index, 1, function(x) final.probs.mat[x[1], x[2]])
# prob.success.p0 <- apply(index, 1, function(x) final.probs.mat.p0[x[1], x[2]])
success <- data.frame(Sm=Sm.success, m=m.success, prob=prob.success, success=rep("Success", length(m.success)))
#
# CAN FIND POWER AND TYPE I ERROR AT THIS POINT.
# IF TOO LOW OR HIGH, STOP AND MOVE ON:
#
# pwr <- sum(success[,"prob"])
# typeI <- sum(success[,"prob.p0"])
pwr <- sum(prob.success)
typeI <- sum(prob.success.p0)
if(pwr < power | typeI > alpha) # | pwr > power+tol | alpha < alpha-tol)
{
return(c(n, r, C, typeI, pwr,  NA, NA, thetaF, thetaE, NA))
}
##### FAILURE:
#first.zero.in.row <- apply(mat[1:(r+1),], 1, function(x) {which.max(x[interims]==0)})
submat <- mat[1:(r+1), interims]
first.zero.in.row <- apply(submat, 1, function(x) match(0, x))
m.fail <- C * as.numeric(first.zero.in.row)
Sm.fail <- as.numeric(names(first.zero.in.row))
#fail.deets <- data.frame(Sm=Sm.fail, m=m.fail)
#fail.deets$prob <- apply(fail.deets, 1, function(x) {final.probs.mat[x["Sm"]+1, x["m"]]})
#fail.deets$prob.p0 <- apply(fail.deets, 1, function(x) {final.probs.mat.p0[x["Sm"]+1, x["m"]]})
fail.deets.prob <- numeric(length(m.fail))
fail.deets.prob.p0 <- numeric(length(m.fail))
for(i in 1:length(m.fail)){
fail.deets.prob[i] <- final.probs.mat[Sm.fail[i]+1, m.fail[i]]
fail.deets.prob.p0[i] <- final.probs.mat.p0[Sm.fail[i]+1, m.fail[i]]
}
# Make df of terminal points:
fail.deets <- data.frame(Sm=Sm.fail, m=m.fail, prob=fail.deets.prob, success=rep("Fail", length(Sm.fail)))
tp <- rbind(fail.deets, success)
tp <- tp[tp$prob>0, ]
#sample.size.expd <- sum(output$m*output$prob)
#sample.size.expd.p0 <- sum(output$m*output$prob.p0)
#sample.size.expd.fail <- sum(fail.deets$m*fail.deets$prob)
#sample.size.expd.p0.fail <- sum(fail.deets$m*fail.deets$prob.p0)
sample.size.expd.fail <- sum(m.fail*fail.deets.prob)
sample.size.expd.p0.fail <- sum(m.fail*fail.deets.prob.p0)
sample.size.expd.success <- sum(m.success*prob.success)
sample.size.expd.p0.success <- sum(m.success*prob.success.p0)
sample.size.expd <- sample.size.expd.fail + sample.size.expd.success
sample.size.expd.p0 <- sample.size.expd.p0.fail + sample.size.expd.p0.success
############ EFFECTIVE N. THE "EFFECTIVE N" OF A STUDY IS THE "REAL" MAXIMUM SAMPLE SIZE
######## The point is where every Sm for a given m equals zero or one is necessarily where a trial stops
#cp.colsums <- apply(mat, 2, function(x) { sum(x==0, na.rm=TRUE)+sum(x==1, na.rm=TRUE)} ) # Sum the CP values that equal zero or one in each column
cp.colsums <- colSums(mat==0, na.rm = T) + colSums(mat==1, na.rm = T)
# possible.cps <- apply(mat, 2, function(x) {sum(!is.na(x))})
possible.cps <- colSums(!is.na(mat))
effective.n <- min(which(cp.colsums==possible.cps))
return.vec <- c(n, r, C, typeI, pwr, sample.size.expd.p0, sample.size.expd, thetaF, thetaE, effective.n)
if(return.tps==TRUE){
return.list <- list(ocs=return.vec, tp=tp)
return(return.list)
}
return.vec
}
# Add CPs to fig 2.1(d):
n <- 8
nmax <- n
r <- 4
Csize <- 1
p0 <- 0.2 # can be changed
p1 <- 0.4 # can be changed
q0 <- 1-p0
q1 <- 1-p1
thetaF <- 0.2 # can be changed
thetaE <- 0.9 # can be changed
alpha <- 0.05 # can be changed
power <- 0.9 # can be changed
mat.list <- curtailment:::findCPmatrix(n=n, r=r, Csize=Csize, p0=p0, p1=p1)
##### Matrix of coefficients: Probability of a SINGLE path leading to each point:
coeffs <- matrix(NA, ncol=nmax, nrow=nmax+1)
coeffs.p0 <- coeffs
for(i in 1:(nmax+1)){
coeffs[i, ] <- p1^(i-1) * q1^((2-i):(2-i+nmax-1))
coeffs.p0[i, ] <- p0^(i-1) * q0^((2-i):(2-i+nmax-1))
}
n <- 8
nmax <- n
r <- 4
Csize <- 1
p0 <- 0.2 # can be changed
p1 <- 0.4 # can be changed
q0 <- 1-p0
q1 <- 1-p1
thetaF <- 0.2 # can be changed
thetaE <- 0.9 # can be changed
alpha <- 0.05 # can be changed
power <- 0.9 # can be changed
mat.list <- curtailment:::findCPmatrix(n=n, r=r, Csize=Csize, p0=p0, p1=p1)
##### Matrix of coefficients: Probability of a SINGLE path leading to each point:
coeffs <- matrix(NA, ncol=nmax, nrow=nmax+1)
coeffs.p0 <- coeffs
for(i in 1:(nmax+1)){
coeffs[i, ] <- p1^(i-1) * q1^((2-i):(2-i+nmax-1))
coeffs.p0[i, ] <- p0^(i-1) * q0^((2-i):(2-i+nmax-1))
}
coeffs
mat
mat <- matrix(NA, nrow=6, ncol=8)
mat
rownames(mat) <- 0:5
mat
mat[1,3] <- 0
mat[2,4] <- 0
mat[3,6] <- 0
mat[4,7] <- 0
mat[5,8] <- 0
mat[6,5:8]<-1
mat
for(j in 7:1){
for(i in 5:1){
mat[i,j] <- p1*mat[i+1,j+1] + (1-p1)*mat[i+1,j]
}
mat
p1
i=5;j=7
p1*mat[i+1,j+1] + (1-p1)*mat[i+1,j]
p1*mat[i+1,j+1]
(1-p1)*mat[i+1,j]
mat <- matrix(NA, nrow=6, ncol=8)
rownames(mat) <- 0:5
mat[1,3] <- 0
mat[2,4] <- 0
mat[3,6] <- 0
mat[4,7] <- 0
mat[5,8] <- 0
mat[6,5:8]<-1
for(j in 7:1){
for(i in 5:1){
mat[i,j] <- p1*mat[i+1,j+1] + (1-p1)*mat[i,j+1]
}
mat
j.vec <- 7:1
mat <- matrix(NA, nrow=6, ncol=8)
rownames(mat) <- 0:5
mat[1,3] <- 0
mat[2,4] <- 0
mat[3,6] <- 0
mat[4,7] <- 0
mat[5,8] <- 0
mat[6,5:8]<-1
mat
mat <- matrix(NA, nrow=6, ncol=8)
rownames(mat) <- 0:5
mat[1,3] <- 0
mat[2,4] <- 0
mat[3,6] <- 0
mat[4,7] <- 0
mat[5,8] <- 0
mat[6,5:8]<-1
j.vec <- 7:1
#i.list <- list(c())
for(j in 7:1){
for(i in 5:1){
if(!is.na(mat[i+1,j+1]) & !is.na(mat[i,j+1])){
mat[i,j] <- p1*mat[i+1,j+1] + (1-p1)*mat[i,j+1]
}
mat
p1
q1
p1+p1*q1
p1^2
p1+p1*q1^2
p1+(p1*q1^2)
p1^3
p1+q1*(p1+p1*q1)
208/365
110*208/365
library(available)
available("moms")
library(curtailment)
library(devtools)
devtools::install_github("martinlaw/curtailment")
.libPaths()
.libPaths()[2]
file.path()
.libPaths() <- c(.libPaths(), "H:\R_package_library")
.libPaths() <- c(.libPaths(), "H:\\R_package_library")
.libPaths <- c(.libPaths(), "H:\\R_package_library")
.libPaths
devtools::install_github("martinlaw/curtailment")
library(BurStMisc)
install.packages("dplyr")
install.packages("dplyr")
.libPaths
.libPaths()
.libPaths(newpath="H:\R_package_library")
.libPaths(newpath="\\\\bliss-03-nfs/homes/martin/R_package_library")
?.libPaths
.libPaths()
new <- c(.libPaths(), "\\\\bliss-03-nfs/homes/martin/R_package_library")
new
.libPaths(new)
.libPaths()
devtools::install_github("martinlaw/curtailment")
devtools::install_github("martinlaw/curtailment", lib=.libPaths()[3])
new <- c( "\\\\bliss-03-nfs/homes/martin/R_package_library", .libPaths())
new
devtools::install_github("martinlaw/curtailment")
?devtools::install_github
install.packages("dplyr")
install.packages("dplyr")
install.packages("dplyr")
install.packages("dplyr")
