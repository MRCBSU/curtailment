UseMethod("drawDiagram")
}
#' @export
drawDiagram.curtailment_single <- function(findDesign.output, print.row=NULL, save.plot=FALSE, xmax=NULL, ymax=NULL){
des <- findDesign.output$all.des
row.names(des) <- 1:nrow(des)
if(!is.null(print.row)){
des <- des[print.row, , drop=FALSE]
}
print(des)
des.input <- findDesign.output$input
if(nrow(des)>1){
rownum <- 1
while(is.numeric(rownum)){
rownum <- readline("Input a row number to choose a design and see the trial design diagram. Press 'q' to quit: ")
if(rownum=="q"){
if(exists("plot.and.bounds")){
return(plot.and.bounds)
}else{
print("No designs selected, nothing to return", q=F)
return()
}
}else{
rownum <- as.numeric(rownum)
plot.and.bounds <- createPlotAndBounds(des=des, des.input=des.input, rownum=rownum, save.plot=save.plot, xmax=xmax, ymax=ymax)
}
} # end of while
}else{
print("Returning diagram and bounds for single design.", quote = F)
plot.and.bounds <- createPlotAndBounds(des=des, des.input=des.input, rownum=1, save.plot=save.plot, xmax=xmax, ymax=ymax)
return(plot.and.bounds)
}
} # end of drawDiagram()
#' @export
drawDiagram.curtailment_simon <- function(findDesign.output, print.row=NULL, save.plot=FALSE, xmax=NULL, ymax=NULL){
des <- findDesign.output$all.des
row.names(des) <- 1:nrow(des)
if(!is.null(print.row)){
des <- des[print.row, , drop=FALSE]
}
print(des)
des.input <- findDesign.output$input
if(nrow(des)>1){
rownum <- 1
while(is.numeric(rownum)){
rownum <- readline("Input a row number to choose a design and see the trial design diagram. Press 'q' to quit: ")
if(rownum=="q"){
if(exists("plot.and.bounds")){
return(plot.and.bounds)
}else{
print("No designs selected, nothing to return", q=F)
return()
}
}else{
rownum <- as.numeric(rownum)
plot.and.bounds <- createPlotAndBoundsSimon(des=des, des.input=des.input, rownum=rownum, save.plot=save.plot, xmax=xmax, ymax=ymax)
}
} # end of while
}else{
print("Returning diagram and bounds for single design.", quote = F)
plot.and.bounds <- createPlotAndBoundsSimon(des=des, des.input=des.input, rownum=1, save.plot=save.plot, xmax=xmax, ymax=ymax)
return(plot.and.bounds)
}
}
drawDiagram(sing)
createPlotAndBounds2arm <- function(des, des.input, rownum, save.plot, xmax, ymax){
rownum <- as.numeric(rownum)
des <- des[rownum, , drop=FALSE]
initial.stop.bounds <- findBounds(des=des,
des.input=des.input)
initial.stop.bounds <- data.frame(t(initial.stop.bounds))
initial.stop.bounds <- cbind(as.numeric(rownames(initial.stop.bounds)), initial.stop.bounds)
names(initial.stop.bounds) <- c("m", "fail", "success")
tp.fail.components <- apply(initial.stop.bounds, 1, function(x) data.frame(0:x["fail"], rep(x["m"], length(0:x["fail"]))))
tp.fail <- do.call(rbind, tp.fail.components)
names(tp.fail) <- c("Sm", "m")
tp.success.components <- apply(initial.stop.bounds, 1, function(x) data.frame(x["success"]:x["m"], rep(x["m"], length(x["success"]:x["m"]))))
tp.success <- do.call(rbind, tp.success.components)
names(tp.success) <- c("Sm", "m")
coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
# for(i in 1:nrow(tp.success.unneeded)){
#   unneeded.success.index <- diag.df$Sm==tp.success.unneeded$Sm[i] & diag.df$m==tp.success.unneeded$m[i]
#   diag.df$decision[unneeded.success.index] <- NA
# }
# Add shading:
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
browser()
diag.df.subset$analysis[diag.df.subset$m %% des$block == 0] <- "Yes"
plot.title <- "Stopping boundaries"
sub.text1 <- paste("Max no. of analyses: ", des$stage, ". Max(N): ", des$n, ". ESS(p", sep="")
sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
sub.text3 <- paste("):", round(des$Ess, 1), sep="")
plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses on treatment + non-responses on control",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
xbreaks <- seq(from=des.input$block, to=des$n, by=des.input$block)
if(!is.null(xmax)){
diagram <- diagram +
expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
expand_limits(y=ymax)
}
diagram <- diagram +
scale_x_continuous(breaks=xbreaks)+
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
print(diagram)
if(save.plot==TRUE){
save.plot.yn <- readline("Save plot? (y/n): ")
if(save.plot.yn=="y"){
plot.filename <- readline("enter filename (no special characters or inverted commas): ")
plot.filename <- paste(plot.filename, ".pdf", sep="")
plot.width <- 8
scaling <- 1.25
plot.height <- 8*scaling*(des$r+1)/des$n
pdf(plot.filename, width = plot.width, height = plot.height)
print(diagram)
dev.off()
}
}
tp.success.unique.m <- tp.success[!duplicated(tp.success$m), ]
stop.bounds <- data.frame(m=seq(from=des$block, to=des$n, by=des$block),
success=Inf,
fail=-Inf)
stop.bounds$success[match(tp.success.unique.m$m, stop.bounds$m)] <- tp.success.unique.m$Sm
stop.bounds$fail[match(tp.fail$m, stop.bounds$m)] <- tp.fail$Sm
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
#' @export
drawDiagram.curtailment_twoarm <- function(findDesign.output, print.row=NULL, save.plot=FALSE, xmax=NULL, ymax=NULL){
des <- findDesign.output$all.des
row.names(des) <- 1:nrow(des)
if(!is.null(print.row)){
des <- des[print.row, , drop=FALSE]
}
print(des)
des.input <- findDesign.output$input
if(nrow(des)>1){
rownum <- 1
while(is.numeric(rownum)){
rownum <- readline("Input a row number to choose a design and see the trial design diagram. Press 'q' to quit: ")
if(rownum=="q"){
if(exists("plot.and.bounds")){
return(plot.and.bounds)
}else{
print("No designs selected, nothing to return", q=F)
return()
}
}else{
rownum <- as.numeric(rownum)
plot.and.bounds <- createPlotAndBounds2arm(des=des, des.input=des.input, rownum=rownum, save.plot=save.plot, xmax=xmax, ymax=ymax)
}
} # end of while
}else{
print("Returning diagram and bounds for single design.", quote = F)
plot.and.bounds <- createPlotAndBounds2arm(des=des, des.input=des.input, rownum=1, save.plot=save.plot, xmax=xmax, ymax=ymax)
return(plot.and.bounds)
}
} # end of drawDiagram()
drawDiagram(des)
head(diag.df.subset)
des$block
initial.stop.bounds
source("R/2arm_1-reproduce-results-functions-find-designs.R")
source("R/2arm_3-reproduce-results-functions-for-tables-plots.R")
source("R/singlearm_functions.R")
drawDiagram(des)
drawDiagram(sing)
sing <- singlearmDesign(nmin = 20, nmax = 20, C = 4, p0 = 0.1, p1 = 0.4, power = 0.8, alpha = 0.1)
sing
drawDiagram(sing)
sing <- singlearmDesign(nmin = 30, nmax = 30, C = 4, p0 = 0.1, p1 = 0.4, power = 0.8, alpha = 0.1)
##################### FUNCTION findDesignsGivenCohortStage
findDesignsGivenCohortStage <- function(nmin,
nmax,
C=NA,
stages=NA,
p0,
p1,
alpha,
power,
maxthetaF=p1,
minthetaE=p1,
bounds="wald",
return.only.admissible=TRUE,
max.combns=1e6,
maxthetas=NA,
fixed.r=NA,
exact.thetaF=NA,
exact.thetaE=NA)
{
require(tcltk)
require(data.table)
q0 <- 1-p0
q1 <- 1-p1
#use.stages <- ifelse(test=is.na(C), yes = TRUE, no = FALSE)
use.stages <- is.na(C)
if(!is.na(C) & !is.na(stages)) stop("Values given for both cohort/block size C and number of stages. Please choose one only.")
# if(use.stages==TRUE){
#   if(nmin%%stages!=0) stop("nmin must be a multiple of number of stages")
#   if(nmax%%stages!=0) stop("nmax must be a multiple of number of stages")
#   nposs <- seq(from=nmin, to=nmax, by=stages)
# } else {
#   if(nmin%%C!=0) stop("nmin must be a multiple of cohort size")
#   if(nmax%%C!=0) stop("nmax must be a multiple of cohort size")
#   nposs <- seq(from=nmin, to=nmax, by=C)
#   }
browser()
n.initial.range <- nmin:nmax
if(use.stages==TRUE){
nposs.min.index <- min(which((nmin:nmax)%%stages==0)) # nmin must be a multiple of number of stages
nposs.min <- n.initial.range[nposs.min.index]
nposs.max.index <- max(which((nmin:nmax)%%stages==0)) # nmax must be a multiple of number of stages
nposs.max <- n.initial.range[nposs.max.index]
nposs <- seq(from=nposs.min, to=nposs.max, by=stages)
}else{
nposs.min.index <- min(which((nmin:nmax)%%C==0)) # nmin must be a multiple of cohort size
nposs.min <- n.initial.range[nposs.min.index]
nposs.max.index <- max(which((nmin:nmax)%%C==0)) # nmax must be a multiple of cohort size
nposs.max <- n.initial.range[nposs.max.index]
nposs <- seq(from=nposs.min, to=nposs.max, by=C)
}
r <- list()
for(i in 1:length(nposs))
{
r[[i]] <- 0:(nposs[i]-1) # r values: 0 to nposs[i]-1
}
ns <- NULL
for(i in 1:length(nposs)){
ns <- c(ns, rep(nposs[i], length(r[[i]])))
}
sc.subset <- data.frame(n=ns, r=unlist(r))
if(!is.na(bounds)){
# Incorporate A'Hern's bounds:
if(bounds=="ahern")  {
sc.subset <- sc.subset[sc.subset$r >= p0*sc.subset$n & sc.subset$r <= p1*sc.subset$n, ]
}
if(bounds=="wald"){
# Faster to incorporate Wald's bounds:
denom <- log(p1/p0) - log((1-p1)/(1-p0))
accept.null <- log((1-power)/(1-alpha)) / denom  + nposs * log((1-p0)/(1-p1))/denom
accept.null <- floor(accept.null)
reject.null <- log((power)/alpha) / denom  + nposs * log((1-p0)/(1-p1))/denom
reject.null <- ceiling(reject.null)
r.wald <- NULL
ns.wald <- NULL
for(i in 1:length(nposs)){
r.wald <- c(r.wald, accept.null[i]:reject.null[i])
ns.wald <- c(ns.wald, rep(nposs[i], length(accept.null[i]:reject.null[i])))
}
sc.subset <- data.frame(n=ns.wald, r=r.wald)
}
}
# In case user wishes to specify values for r:
if(!is.na(fixed.r)){
sc.subset <- sc.subset[sc.subset$r %in% fixed.r,]
}
sc.subset <- sc.subset[sc.subset$r>=0, ]
sc.subset <- sc.subset[sc.subset$r<sc.subset$n, ]
if(use.stages==TRUE){
sc.subset$C <- sc.subset$n/stages
} else {
sc.subset$C <- C
}
###### Find thetas for each possible {r, N} combn:
mat.list <- vector("list", nrow(sc.subset))
for(i in 1:nrow(sc.subset)){
mat.list[[i]] <- findCPmatrix(n=sc.subset[i,"n"], r=sc.subset[i,"r"], Csize=sc.subset[i,"C"], p0=p0, p1=p1)
}
store.all.thetas <- lapply(mat.list, function(x) {sort(unique(c(x))[unique(c(x)) <= 1])})
if(!is.na(max.combns) & is.na(maxthetas)){ # Only use max.combns if maxthetas is not specified.
maxthetas <- sqrt(2*max.combns)
}
if(is.na(exact.thetaF)){
for(i in 1:nrow(sc.subset)){
current.theta.vec <- store.all.thetas[[i]]
store.all.thetas[[i]] <- current.theta.vec[current.theta.vec >= minthetaE | current.theta.vec <= maxthetaF] # Subset thetas BEFORE thinning
while(length(store.all.thetas[[i]]) > maxthetas){
every.other.element <- rep(c(FALSE, TRUE), 0.5*(length(store.all.thetas[[i]])-2))
store.all.thetas[[i]] <-  store.all.thetas[[i]][c(TRUE, every.other.element, TRUE)]
}
}
all.theta.combns <- lapply(store.all.thetas, function(x) {t(combn(x, 2)) })
for(i in 1:nrow(sc.subset)){
all.theta.combns[[i]] <- all.theta.combns[[i]][all.theta.combns[[i]][,2] >= minthetaE & all.theta.combns[[i]][,1] <= maxthetaF, ] # Remove ordered pairs where both are low or high
if(length(all.theta.combns[[i]])==2) all.theta.combns[[i]] <- matrix(c(0, 0.999, 0, 1), nrow=2, byrow=T) # To avoid a crash. See (*) below
all.theta.combns[[i]] <- all.theta.combns[[i]][order(all.theta.combns[[i]][,2], decreasing=T),]
}
# (*) If the only thetas for a design are 0 and 1, then some code below will crash. This could be resolved by adding an if or ifelse statement,
# but probably at unnecessary computational expense. We deal with these exceptions here, by adding a "false" value for theta.
}else{ # if exact thetas are given (to speed up a result check):
for(i in 1:length(store.all.thetas)){
keep <- abs(store.all.thetas[[i]]-exact.thetaF)<1e-3 | abs(store.all.thetas[[i]]-exact.thetaE)<1e-3
store.all.thetas[[i]] <- store.all.thetas[[i]][keep]
}
all.theta.combns <- lapply(store.all.thetas, function(x) {t(combn(x, 2)) })
}
# find
##### Matrix of coefficients: Probability of a SINGLE path leading to each point:
coeffs <- matrix(NA, ncol=nmax, nrow=nmax+1)
coeffs.p0 <- coeffs
for(i in 1:(nmax+1)){
coeffs[i, ] <- p1^(i-1) * q1^((2-i):(2-i+nmax-1))
coeffs.p0[i, ] <- p0^(i-1) * q0^((2-i):(2-i+nmax-1))
}
h.results.list <- vector("list", nrow(sc.subset)) #
pb <- txtProgressBar(min = 0, max = nrow(sc.subset), style = 3)
######### START HERE
# Now, find the designs, looping over each possible {r, N} combination, and within each {r, N} combination, loop over all combns of {thetaF, thetaE}:
for(h in 1:nrow(sc.subset)){
k <- 1
h.results <- vector("list", nrow(all.theta.combns[[h]]))
current.theta.combns <- all.theta.combns[[h]] # Take just the thetaF/1 combns for that design.
# Don't need a matrix of all thetaF and thetaE combns -- potentially quicker to have thetaF as a vector (already defined), and the list can be a list of thetaE vectors:
current.theta.combns <- data.table::data.table(current.theta.combns)
current.theta.combns[, grp := .GRP, by = V2]
data.table::setkey(current.theta.combns, grp)
split.thetas <- current.theta.combns[, list(list(.SD)), by = grp]$V1
thetaF.list <- lapply(split.thetas, function(x) x[, 1])
all.thetas <- rev(store.all.thetas[[h]])[-length(store.all.thetas[[h]])] # All thetaE values, decreasing, not including the final value, thetaE=0.
all.thetas <- all.thetas[all.thetas>=minthetaE]
for(i in 1:length(all.thetas)){ # For each thetaE,
thetaFs.current <- thetaF.list[[i]] # thetaF.list is a list of i vectors. The i'th vector in the list contains all possible values of thetaF for the i'th thetaE (stored as all.thetas[i])
rows <- nrow(thetaFs.current)
# Begin bisection method:
a <- 1
b <- nrow(thetaFs.current)
d <- ceiling((b-a)/2)
while((b-a)>1){
output <- findDesignOCs(n=sc.subset$n[h], r=sc.subset$r[h], C=sc.subset$C[h], thetaF=as.numeric(thetaFs.current[d]), thetaE=all.thetas[i], mat=mat.list[[h]],
power=power, alpha=alpha, coeffs=coeffs, coeffs.p0=coeffs.p0, p0=p0, p1=p1)
if(output[4] <= alpha) { # type I error decreases as index (and thetaF) increases. Jump backwards if type I error is smaller than alpha, o/w forwards.
b <- d
} else {
a <- d
}
d <- a + floor((b-a)/2)
}
# Take care of "edge case" where feasible design exists in the first row:
if(a==1) { # (and also by necessity, b==2)
output <-  findDesignOCs(n=sc.subset$n[h], r=sc.subset$r[h], C=sc.subset$C[h], thetaF=as.numeric(thetaFs.current[1]), thetaE=all.thetas[i], mat=mat.list[[h]],
power=power, alpha=alpha, coeffs=coeffs, coeffs.p0=coeffs.p0, p0=p0, p1=p1)
if(output[4] <= alpha) b <- 1 # Should we start at the first row or the second?
}
# We can now proceed moving sequentially from index==b (or cause a break if we wish).
first.result <-  findDesignOCs(n=sc.subset$n[h], r=sc.subset$r[h], C=sc.subset$C[h], thetaF=as.numeric(thetaFs.current[b]), thetaE=all.thetas[i],
mat=mat.list[[h]], coeffs.p0=coeffs.p0, coeffs=coeffs, power=power, alpha=alpha, p0=p0, p1=p1)
if((first.result[4]!=0 | first.result[4]!=2) ) {
pwr <- first.result[5]
while(pwr >= power & b <= rows) # Keep going until power drops below 1-beta, i.e. no more feasible designs, or we reach the end of the data frame.
{
h.results[[k]] <-  findDesignOCs(n=sc.subset$n[h], r=sc.subset$r[h], C=sc.subset$C[h], thetaF=as.numeric(thetaFs.current[b]), thetaE=all.thetas[i],
mat=mat.list[[h]], coeffs.p0=coeffs.p0, coeffs=coeffs, power=power, alpha=alpha, p0=p0, p1=p1)
pwr <- h.results[[k]][5] ####
k <- k+1
b <- b+1
}
} else { # if first.result[4]==0 or 2, i.e., there are no feasible designs for this thetaE (and hence no remaining feasible designs for this n/r combn), break and move on to next n/r combn:
break
}
# If there is only one possible combination of thetaF and thetaE, this is the result:
if(rows==1){
h.results[[k]] <- output
k <- k+1
}
} # end of "i" loop
setTxtProgressBar(pb, h)
####### END HERE
h.results.df <- do.call(rbind, h.results)
if(!is.null(h.results.df)){
# Remove all "skipped" results:
colnames(h.results.df) <- c("n", "r", "C", "alpha", "power", "EssH0", "Ess", "thetaF", "thetaE", "eff.n")
h.results.df <- h.results.df[!is.na(h.results.df[, "Ess"]),]
if(nrow(h.results.df)>0){
# Remove dominated and duplicated designs:
discard <- rep(NA, nrow(h.results.df))
for(i in 1:nrow(h.results.df)){
discard[i] <- sum(h.results.df[i, "EssH0"] > h.results.df[, "EssH0"] & h.results.df[i, "Ess"] > h.results.df[, "Ess"] & h.results.df[i, "n"] >= h.results.df[, "n"])
}
h.results.df <- h.results.df[discard==0,, drop=FALSE]
h.results.list[[h]] <- h.results.df
}
}
} # End of "h" loop
full.results <- do.call(rbind, h.results.list)
if(length(full.results)>0) {
if(return.only.admissible==TRUE){
# Discard all "inferior" designs:
discard <- rep(NA, nrow(full.results))
for(i in 1:nrow(full.results)){
discard[i] <- sum(full.results[i, "EssH0"] > full.results[, "EssH0"] & full.results[i, "Ess"] > full.results[, "Ess"] & full.results[i, "n"] >= full.results[, "n"])
}
full.results <- full.results[discard==0,,drop=FALSE]
}
# Remove duplicates:
duplicates <- duplicated(full.results[, c("n", "Ess", "EssH0"), drop=FALSE])
final.results <- full.results[!duplicates,,drop=FALSE]
stage <- final.results[,"n"]/final.results[,"C"]
final.results <- cbind(final.results, stage)
} else {
final.results <- NULL
if(nmin!=nmax){
print("There are no feasible designs for this combination of design parameters")
return(final.results)
}
}
# input <- data.frame(nmin=nmin, nmax=nmax,
#                     #nmin.used=nposs.min, nmax.used=nposs.max,
#                     C=C, stages=stages, p0=p0, p1=p1, alpha=alpha, power=power,
#                     maxthetaF=maxthetaF, minthetaE=minthetaE, bounds=bounds, fixed.r=fixed.r,
#                     return.only.admissible=return.only.admissible, max.combns=max.combns,
#                     maxthetas=maxthetas, exact.thetaF=exact.thetaF, exact.thetaE=exact.thetaE)
# return(list(input=input,
#             all.des=final.results,
#             bounds.mat=single.des$bounds.mat,
#             diagr=single.des$diagram
#             ))
return(final.results)
}
sing <- singlearmDesign(nmin = 30, nmax = 30, C = 4, p0 = 0.1, p1 = 0.4, power = 0.8, alpha = 0.1)
use.stages
n.initial.range
nmin:nmax
min(which((nmin:nmax)%%C==0))
max(which((nmin:nmax)%%C==0))
is.infinite(1,2)
source("R/singlearm_functions.R")
sing <- singlearmDesign(nmin = 30, nmax = 30, C = 4, p0 = 0.1, p1 = 0.4, power = 0.8, alpha = 0.1)
source("R/singlearm_functions.R")
sing <- singlearmDesign(nmin = 30, nmax = 30, C = 4, p0 = 0.1, p1 = 0.4, power = 0.8, alpha = 0.1)
sing <- singlearmDesign(nmin = 30, nmax = 30, C = 5, p0 = 0.1, p1 = 0.4, power = 0.8, alpha = 0.1)
sing
drawDiagram(sing)
sing <- singlearmDesign(nmin = 30, nmax = 30, C = 5, p0 = 0.1, p1 = 0.4, power = 0.8, alpha = 0.05)
sing
drawDiagram(sing)
devtools::document()
# Check Equn (2.2):
# Say N=10, r=5, m=7, Sm=4. Then 10-7=3 results remaining, and need at least 2 responses to reach r+1=6.
# CP is then P(2 responses out of 3 remaining) + P(3 responses out of 3 remaining). Work it out:
N=10; r=5; m=7; Sm=4; p1=0.3
# Check Equn (2.2):
# Say N=10, r=5, m=7, Sm=4. Then 10-7=3 results remaining, and need at least 2 responses to reach r+1=6.
# CP is then P(2 responses out of 3 remaining) + P(3 responses out of 3 remaining). Work it out:
N=10; r=5; m=7; Sm=4; p1=0.3; q1=1-p1
choose(3, 2)*p1^2*q1^(3-2) + choose(3, 3)*p1^3*q1^(3-3)
# Now try equn 2.2:
r-Sm
N-m-1
# Now try equn 2.2:
r-Sm
N-m-1
# So find A(i,r) from i=1 to 2.
A
# So find A(i,r) from i=1 to 2.
A <- function(x,y,Sm=4,p1=0.3){
choose(x, y-Sm)*p1^(y-Sm+1)*(1-p1)^(x-(y-Sm))
}
A(1,5)
A(1,5)+A(2,5)
choose(3, 2)*p1^2*q1^(3-2) + choose(3, 3)*p1^3*q1^(3-3)
A(1,5)+A(2,5)
# Try another example:
N=20; r=5; m=16; Sm=4; p1=0.3; q1=1-p1
choose(4, 2)*p1^2*q1^(4-2) + choose(4, 3)*p1^3*q1^(4-3) + choose(4, 4)*p1^4*q1^(4-4)
r-Sm
N-m-1
# So find A(i,r) from i=1 to 3.
A(1,5)+A(2,5)+A(3,5)
# Vectorised:
i=1:3
choose(4, j)*p1^2*q1^(4-j)
# Vectorised:
j=2:4
choose(4, j)*p1^2*q1^(4-j)
sum(choose(4, j)*p1^2*q1^(4-j))
choose(4, j)*p1^j*q1^(4-j)
sum(choose(4, j)*p1^j*q1^(4-j))
library(fertile)
proj_check()
