# Now we have the rows and columns of this region:
# cp.subset2.Sm # Values of Sm. Rows are this plus 1.
# cp.subset2.m # Values of m (columns)
# Have to propagate "backwards", ending at Sm=0, n=1.
# As with previous region, proceed row-wise -- start with greatest Sm.
# for(k in length(cp.subset2.Sm):1) # Note that we END at the earliest row.
# {
#   for(j in rev(cp.subset2.m[[k]]))
#     {
#     mat[k, j] <- q*mat[k, j+1] + p*mat[k+1, j+1]
#     }
# }
# This *must* be done in this way -- cannot be vectorised.
# Create the "blanks":
# for(i in 1:(ncol(mat)-1))
# {
#   mat[(i+2):nrow(mat), i] <- NA
# }
NAs <- rbind(FALSE, lower.tri(mat)[-nrow(mat),])
mat[NAs] <- NA
# all.thetas <- unique(c(mat))
# subset.thetas <- all.thetas[all.thetas < 0.2]
# We now have a matrix m containing the CPs in (more or less) the upper triangle.
######################
######IMPORTANT ######
######################
# If a point in a path has CP < theta, we stop the trial due to stochastic curtailment.
# If an earlier point in the path leads only to curtailment of some kind -- non-stochastic, stochastic, or both --
# then the CP of that earlier point is essentially zero. There is no point in "reaching" it.
# Similarly, if an earlier point in the path *may* lead to curtailment of some kind, the CP of that earlier point must change.
# With the above in mind, it seems that it is not possible to separate the calculation of CP from the comparison of CP against theta;
# They must be undertaken together.
###### NEXT SECTION: CHECKING IF EACH CP<THETA0 OR CP>THETA1 ######
# Begin at row r+1, i.e. where Sm=r, and at column n-1.
# Proceed right to left then bottom to top, ignoring cases where CP=0 or CP=1.
# As CP increases from right to left, if CP>=theta then can move on to next row (because all CPs will be >=theta).
# The CPs in regions A and B have already been defined above; these are the points
# for which 0 < CP < 1. Combine these regions and examine:
cp.sm <- c(cp.subset2.Sm, cp.subset1.Sm)
cp.m <- c(cp.subset2.m, cp.subset1.m)
# ^ These are all the points that it is necessary to cycle through.
# To reduce looping, identify the rows which contain a CP < theta0 OR CP > theta1:
# theta.test <- function(Sm, m)
#   {
#   sum(mat[Sm+1, m] < theta0 | mat[Sm+1, m] > theta1)
# }
#
# low.cp.rows <- mapply(theta.test, Sm=cp.sm, m=cp.m)
# Because of how CP changes, propagating right to left and upwards, we only
# need to identify the "lowest" row with CP < theta or CP > theta1, ie the row with greatest Sm
# that contains a CP < theta or CP > theta1. This is the row where we begin. Note: This may be all rows, or even none!
# Recall that row number = Sm-1
# mat.old <- mat
# We only need to act if there are CPs < theta0 or > theta1 -- otherwise, the matrix of CPs does not change.
# if(sum(low.cp.rows)>0)    # There may be some cases where there are no CPs to be changed; i.e. no stopping due to stochastic curtailment
# {
#   begin.at.row <- max(which(low.cp.rows>0))
#
#   cp.changing.sm <- cp.sm[1:begin.at.row]
#   cp.changing.m <- cp.m[1:begin.at.row]
#
#
#   # We calculate the CP, truncate to zero if CP<theta0 (or to 1 if CP > theta1), then move on:
#
# for(rown in rev(cp.changing.sm+1))
#   {
#   for(coln in rev(cp.changing.m[[rown]]))
#     {
#     currentCP <- q*mat[rown, coln+1] + p*mat[rown+1, coln+1]
#     if(currentCP > theta1)   mat[rown, coln] <- 1   # If CP > theta1, amend to equal 1
#     else  mat[rown, coln] <- ifelse(test = currentCP < theta0, yes=0, no=currentCP)  # Otherwise, test if CP < theta0. If so, amend to 0, otherwise calculate CP as normal
#     }
#   } # Again, this *must* be done one entry at a time -- cannot vectorise.
#
#
# } # End of IF statement
#
# mat
###### STOP if design is pointless, i.e either failure or success is not possible from the beginning:
# if(sum(mat[,1], na.rm = T)==2) stop("Design guarantees success")
# if(sum(mat[,1], na.rm = T)==0) stop("Design guarantees failure")
###### At this point, the matrix "mat" contains the CPs, adjusted for stochastic curtailment.
###### The points in the path satisfying 0 < CP < 1 are the possible points for this design;
###### All other points are either terminal (i.e. points of curtailment) or impossible.
###### We now need the characteristics of this design: Type I error, expected sample size, and so on.
pascal.list <- list(1, c(1,1))
# for(i in 3:(n+2))
# {
# column <- as.numeric(mat[!is.na(mat[,i-2]), i-2])
# CPzero.or.one <- which(column==0 | column==1)
# newnew <- pascal.list[[i-1]]
# newnew[CPzero.or.one] <- 0
# pascal.list[[i]] <- c(0, newnew) + c(newnew, 0)
# }
for(i in 3:(n+2))
{
column <- mat[!is.na(mat[,i-2]), i-2]
CPzero.or.one <- which(column!=0.5)
newnew <- pascal.list[[i-1]]
newnew[CPzero.or.one] <- 0
pascal.list[[i]] <- c(0, newnew) + c(newnew, 0)
}
pascal.list <- pascal.list[c(-1, -length(pascal.list))]
# Now obtain the rest of the probability -- the p^b * q^c :
coeffs <- list()
coeffs.p0 <- list()
for(i in 1:n){
j <- 1:(i+1)
coeffs[[i]] <- p1^(j-1)*q1^(i+1-j)
coeffs.p0[[i]] <- p0^(j-1)*q0^(i+1-j)
}
needed <- (r2+1):n
coeffs2 <- p1^(r2+1)*q1^(needed-(r2+1))
coeffs2.p0 <- p0^(r2+1)*q0^(needed-(r2+1))
# We only want the (r2+2)th element of each list (equivalent to Sm=r2+1, as element 1 is Sm=0), from m=r2+1:
pascal.element.r2plus1 <- sapply(pascal.list, "[", (r2+2))[(r2+1):n]
# single <- lapply(pascal.list, function(x) {x[r2+2]}) # Another way of getting the (r2+1)th element of each list.
# Multiply the two triangles (A and p^b * q^c), needed for Ess under H1:
final.probs <- Map("*", pascal.list, coeffs)
# for finding Ess under H0:
final.probs.p0 <- Map("*", pascal.list, coeffs.p0)
###### We have the probability of each path, taking into account stochastic and NS curtailment. ######
###### We now must tabulate these paths.
final.probs.mat <- matrix(unlist(lapply(final.probs, '[', 1:max(sapply(final.probs, length)))), ncol = n, byrow = F)
#rownames(final.probs.mat) <- 0:n
final.probs.mat.p0 <- matrix(unlist(lapply(final.probs.p0, '[', 1:max(sapply(final.probs.p0, length)))), ncol = n, byrow = F)
#rownames(final.probs.mat.p0) <- 0:n
# Find successful probabilities first:
# m.success <- (r2+1):n
# Sm.success <- rep(r2+1, length(m.success))
# prob.success <- final.probs.mat[r2+2, m.success]
# prob.success.p0 <- final.probs.mat.p0[r2+2, m.success]
# success.deets <- cbind(Sm.success, m.success, prob.success, prob.success.p0)
# FIRST: Search for terminal points of success. These can only exist in rows where (updated) CP=1, and where Sm<=r+1:
#potential.success.rows <- rowSums(mat[1:(r2+2), ]==1, na.rm = TRUE)
#rows.with.cp1 <- which(as.numeric(potential.success.rows)>0)
rows.with.cp1 <- r2+1+1
# ^ These are the rows containing possible terminal points of success. They must have CP=1:
columns.of.rows.w.cp1 <- (r2+1):n
#columns.of.rows.w.cp1 <- list()
#columns.of.rows.w.cp1 <- which(mat[rows.with.cp1, ]==1 & !is.na(mat[rows.with.cp1, ]))
# These rows and columns contain all possible terminal points of success.
# The point CP(Sm, m) is terminal if CP(Sm-1, m-1) < 1 .
# Strictly speaking, CP(Sm, m) is also terminal if CP(Sm, m-1) < 1 .
# However, CP(Sm, m-1) >= CP(Sm-1, m-1)  [I think], so the case of
# CP(Sm, m) == 1  AND  CP(Sm, m-1) < 1 is not possible.
# DEPRECATED -- TOO SLOW. FASTER CODE BELOW
# success <- NULL
# for(i in 1:length(rows.with.cp1))
# {
#   for(j in 1:length(columns.of.rows.w.cp1[[i]]))
#   {
#     if(mat[rows.with.cp1[i] - 1, columns.of.rows.w.cp1[[i]][j] - 1] < 1) success <- rbind(success, c(rows.with.cp1[i]-1, columns.of.rows.w.cp1[[i]][j]))
#   }
# }
# success <- NULL
#
# for(j in columns.of.rows.w.cp1)
#   {
#     if(mat[rows.with.cp1-1, j-1] < 1) success <- rbind(success, c(rows.with.cp1-1, j, final.probs.mat[rows.with.cp1, j], final.probs.mat.p0[rows.with.cp1, j]))
#   }
success.n <- (r2+1):n
success.Sm <- rep(r2+1, length(columns.of.rows.w.cp1))
#success.prob <- final.probs.mat[rows.with.cp1, columns.of.rows.w.cp1]
success.prob <- pascal.element.r2plus1*coeffs2
#success.prob.p0 <- final.probs.mat.p0[rows.with.cp1, columns.of.rows.w.cp1]
success.prob.p0 <-pascal.element.r2plus1*coeffs2.p0
success <- cbind(success.Sm, success.n, success.prob, success.prob.p0)
colnames(success) <- c("Sm", "m", "prob", "prob.p0")
# Now failure probabilities. Note that there is one failure probability in each row, and in that
# row the failure probability is the one that has the greatest m (i.e. the "furthest right" non-zero entry):
# Identify non-zero terms in each row:
m.fail <- rep(NA, r2+1)
prob.fail <- rep(NA, r2+1)
prob.fail.p0 <- rep(NA, r2+1)
for(i in 1:(r2+1))
{
m.fail[i] <- max(which(final.probs.mat[i ,]!=0))
prob.fail[i] <- final.probs.mat[i, m.fail[i]]
prob.fail.p0[i] <- final.probs.mat.p0[i, m.fail[i]]
}
Sm.fail <- 0:r2
fail.deets <- cbind(Sm.fail, m.fail, prob.fail, prob.fail.p0)
output <- rbind(fail.deets, success)
rownames(output) <- NULL
output <- as.data.frame(output)
output$success <- c(rep("Fail", length(m.fail)), rep("Success", nrow(success)))
names(output) <- c("Sm", "m", "prob", "prob.p0", "success")
#print(output)
##################### Now find characteristics of design #####################
sample.size.expd <- sum(output$m*output$prob)
sample.size.expd.p0 <- sum(output$m*output$prob.p0)
#alpha <- sum(output$prob.p0[output$success=="Success"])
#power <- sum(output$prob[output$success=="Success"])
#output <- c(n1=n1, n2=n2, n=n, r1=r1, r=r2, alpha=sum(success.prob.p0), power=sum(success.prob))
output <- c(n1=n1, n2=n2, n=n, r1=r1, r=r2, alpha=sum(success.prob.p0), power=sum(success.prob), EssH0=sample.size.expd.p0, Ess=sample.size.expd)
output
}
#
# system.time({
# for(i in 1:1000) nsc.power.alpha.ess(n1=20, n2=20, r1=5, r2=10, p=0.3, p0=0.1)
# })
#
#   n1=20; n2=20; r1=5; r2=10; p=0.3; p0=0.1
# warnings()
x <- findNSCdesigns(nmin=20, nmax=21, p0=0.1, p1=0.4, alpha=0.1, power=0.8)
x
drawDiagram(x)
drawDiagram(x, print.row=1)
drawDiagram(x, print.row=2)
createPlotAndBoundsSimonNSCreview <- function(des, xmax=NULL, ymax=NULL){
m <- Sm <- decision <- analysis <- NULL
des <- as.data.frame(t(des))
coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
fails.sm <- c(0:des$r1, (des$r1+1):des$r)
# fails.m <- c(rep(des$n1, length(0:des$r1)),
#              rep(des$n, length((des$r1+1):des$r))
#              )
fails.m <- c((des$n1-des$r1):des$n1,
seq(to=des$n, length=des$r-des$r1))
tp.fail <- data.frame(Sm=fails.sm,
m=fails.m)
# tp.success <- data.frame(Sm=(des$r+1):des$n,
#                          m=rep(des$n, length((des$r+1):des$n))
#                          )
tp.success <- data.frame(Sm=rep(des$r+1, des$n-des$r),
m=(des$r+1):des$n
)
# If stopping for benefit:
# if("e1" %in% names(des)){
#   tp.success.s1 <- data.frame(Sm=(des$e1+1):des$n1,
#                               m=rep(des$n1, length((des$e1+1):des$n1))
#                               )
#   tp.success <- rbind(tp.success, tp.success.s1)
# }
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
#diag.df.subset$analysis[diag.df.subset$m %in% tp.fail$m] <- "Yes"
diag.df.subset$analysis[diag.df.subset$m %in% c(tp.fail$m, tp.success$m)] <- "Yes"
# plot.title <- "Stopping boundaries"
# sub.text1 <- paste("Max(N): ", des$n, ". ESS(p", sep="")
# sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
# sub.text3 <- paste("):", round(des$Ess, 1), sep="")
# plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
# Initial setup:
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses"#,
#     title=plot.title,
#     subtitle = plot.subtitle2
)+
coord_cartesian(expand = 0)+
theme_minimal()
xbreaks <- c(des$n1, des$n)
if(!is.null(xmax)){
diagram <- diagram +
expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
expand_limits(y=ymax)
}
diagram <- diagram +
scale_x_continuous(breaks=xbreaks)+
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
print(diagram)
tp.success.unique.m <- tp.success[!duplicated(tp.success$m), ]
stop.bounds <- data.frame(m=sort(union(tp.fail$m, tp.success$m)),
success=Inf,
fail=-Inf)
stop.bounds$success[match(tp.success$m, stop.bounds$m)] <- tp.success$Sm
stop.bounds$fail[match(tp.fail$m, stop.bounds$m)] <- tp.fail$Sm
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
createPlotAndBoundsSimonNSCreview(x$all.des)
x
createPlotAndBoundsSimonNSCreview(x)
createPlotAndBoundsSimonNSCreview(x$all.des)
x$all.des$n
createPlotAndBoundsSimonNSCreview(x$all.des[1,])
createPlotAndBoundsSimon <- function(des, des.input, rownum, xmax=NULL, ymax=NULL){
m <- Sm <- decision <- analysis <- NULL
des <- as.data.frame(des[rownum, ])
coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
fails.sm <- c(0:des$r1, (des$r1+1):des$r)
fails.m <- c(rep(des$n1, length(0:des$r1)),
rep(des$n, length((des$r1+1):des$r))
)
tp.fail <- data.frame(Sm=fails.sm,
m=fails.m)
tp.success <- data.frame(Sm=(des$r+1):des$n,
m=rep(des$n, length((des$r+1):des$n))
)
# If stopping for benefit:
if("e1" %in% names(des)){
tp.success.s1 <- data.frame(Sm=(des$e1+1):des$n1,
m=rep(des$n1, length((des$e1+1):des$n1))
)
tp.success <- rbind(tp.success, tp.success.s1)
}
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
diag.df.subset$analysis[diag.df.subset$m %in% tp.fail$m] <- "Yes"
plot.title <- "Stopping boundaries"
sub.text1 <- paste("Max no. of analyses: 2. Max(N): ", des$n, ". ESS(p", sep="")
sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
sub.text3 <- paste("):", round(des$Ess, 1), sep="")
plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
xbreaks <- c(des$n1, des$n)
if(!is.null(xmax)){
diagram <- diagram +
expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
expand_limits(y=ymax)
}
diagram <- diagram +
scale_x_continuous(breaks=xbreaks)+
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
print(diagram)
stop.bounds <- data.frame(m=c(des$n1, des$n),
success=c(Inf, des$r+1),
fail=c(des$r1, des$r))
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
createPlotAndBoundsSimon(des=x$all.des, des.input=x$input, rownum=1)
createPlotAndBoundsSimon <- function(des, des.input, rownum, xmax=NULL, ymax=NULL){
m <- Sm <- decision <- analysis <- NULL
des <- as.data.frame(des[rownum, ])
coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
fails.sm <- c(0:des$r1, (des$r1+1):des$r)
fails.m <- c(rep(des$n1, length(0:des$r1)),
rep(des$n, length((des$r1+1):des$r))
)
tp.fail <- data.frame(Sm=fails.sm,
m=fails.m)
tp.success <- data.frame(Sm=(des$r+1):des$n,
m=rep(des$n, length((des$r+1):des$n))
)
# If stopping for benefit:
if("e1" %in% names(des)){
tp.success.s1 <- data.frame(Sm=(des$e1+1):des$n1,
m=rep(des$n1, length((des$e1+1):des$n1))
)
tp.success <- rbind(tp.success, tp.success.s1)
}
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
diag.df.subset$analysis[diag.df.subset$m %in% tp.fail$m] <- "Yes"
plot.title <- "Stopping boundaries"
sub.text1 <- paste("Max no. of analyses: 2. Max(N): ", des$n, ". ESS(p", sep="")
sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
sub.text3 <- paste("):", round(des$Ess, 1), sep="")
plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = ggplot2::aes(x=m, y=Sm, fill=decision, alpha=analysis))+
ggplot2::scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
ggplot2::geom_tile(color="white")+
ggplot2::labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses",
title=plot.title,
subtitle = plot.subtitle2)+
ggplot2::coord_cartesian(expand = 0)+
ggplot2::theme_minimal()
xbreaks <- c(des$n1, des$n)
if(!is.null(xmax)){
diagram <- diagram +
ggplot2::expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
ggplot2::expand_limits(y=ymax)
}
diagram <- diagram +
ggplot2::scale_x_continuous(breaks=xbreaks)+
ggplot2::scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
print(diagram)
stop.bounds <- data.frame(m=c(des$n1, des$n),
success=c(Inf, des$r+1),
fail=c(des$r1, des$r))
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
createPlotAndBoundsSimon(des=x$all.des, des.input=x$input, rownum=1)
x
curtailment:::findCPmatrix(n=20,r=5,Csize=4,p0=0.1, p1=0.3)
mat <- curtailment:::findCPmatrix(n=20,r=5,Csize=4,p0=0.1, p1=0.3)
seq(20, 1, by=-4)[-1]
seq(20, 8, by=-4)[-1]
?which.max
seq(20, 1, by=-4)[-1]
pat.cols1 <- seq(20, 1, by=-4)[-1]
pat.cols1
minst <- 10
which.max(pat.cols1>minst)
pat.cols1>minst
pat.cols.ascending <- seq(1, 20, by=4)
pat.cols.ascending
pat.cols.ascending <- seq(4, 20, by=4)
pat.cols.ascending
which.max(pat.cols1>minst)
pat.cols.ascending>minst
which.max(pat.cols.ascending>minst)
pat.cols.ascending[which.max(pat.cols.ascending>minst)]
pat.cols1 <- seq(20, 10, by=-4)
seq(20, 10, by=-4)
CC <- 4
(1:40)%%CC
pat.cols.ascending[which.max(pat.cols.ascending>minst)]
pascal.list <- list(c(1,1))
CC
if(C>1){
for(i in 2:CC){
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
for(i in 2:CC){
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
pascal.list
C<-4
n <- 20
for(i in 1:length(pascal.list)){
pascal.list[[i]] <- c(pascal.list[[i]], rep(0, length(pascal.list)+1-length(pascal.list[[i]])))
}
pascal.list
minstop
minstop<-10
pascal.list <- list(c(1,1))
for(i in 2:minstop){
pascal.list[[i]] <- c(0, pascal.list[[i-1]]) + c(pascal.list[[i-1]], 0)
}
pascal.list
(1:20)%%4
