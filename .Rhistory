success.s1.cum <- success.cum[,1:(2*n1)]
failure.s1.cum <- failure.cum[,1:(2*n1)]
# Which trials fail early due to hitting n1-a1+1 failures?
fail.wrt.s1.boundary.index <- apply(failure.s1.cum, 1, function(x) any(x==s1.nogo))
curtailed.s1.subset <- failure.s1.cum[fail.wrt.s1.boundary.index, , drop=FALSE]
# Sample size of trials curtailed at S1:
s1.curtailed.ss <- apply(curtailed.s1.subset, 1, function(x) which.max(x==s1.nogo))
# Subset cumulative results to only the remaining trials:
success.cum.non.s1.failure.trials.subset <- success.cum[-fail.wrt.s1.boundary.index, , drop=FALSE]
failure.cum.non.s1.failure.trials.subset <- failure.cum[-fail.wrt.s1.boundary.index, , drop=FALSE]
# Of these remaining trials, which trials reach the req'd no. of successes, and after how many participants?
successful.trial.index <- apply(success.cum.non.s1.failure.trials.subset, 1, function(x) any(x==s2.go))
success.cum.successful.trials.subset <- success.cum.non.s1.failure.trials.subset[successful.trial.index, , drop=FALSE]
early.stop.success.ss <- apply(success.cum.successful.trials.subset, 1, function(x) which.max(x==s2.go))
# The remaining trials must fail by reaching the required no. of failures. After how many participants do the trials end?
failure.cum.s2.failure.trials.subset <- failure.cum.non.s1.failure.trials.subset[!successful.trial.index, , drop=FALSE]
early.stop.failure.ss <- apply(failure.cum.s2.failure.trials.subset, 1, function(x) which.max(x==s2.nogo))
# Find type I error, power, ESS:
prob.reject.h0 <- length(early.stop.success.ss)
ess <- sum(s1.curtailed.ss, early.stop.success.ss, early.stop.failure.ss)/runs
#
#     # Split into "curtailed during S1" and "not curtailed during S1". Note: curtail for no go only.
#     curtailed.s1.bin <- apply(failure.s1.cum, 1, function(x) any(x==s1.nogo))
#     curtailed.s1.index <- which(curtailed.s1.bin) # Index of trials/rows that reach the S1 no go stopping boundary
#     curtailed.s1.subset <- failure.s1.cum[curtailed.s1.index, , drop=FALSE]
#     # Sample size of trials curtailed at S1:
#     s1.curtailed.ss <- apply(curtailed.s1.subset, 1, function(x) which.max(x==s1.nogo))
#
#     ########## All other trials progress to S2. Subset these:
#     success.cum.nocurtail.at.s1 <- success.cum[-curtailed.s1.index, , drop=FALSE]
#     failure.cum.nocurtail.at.s1 <- failure.cum[-curtailed.s1.index, , drop=FALSE]
#
#     # Trials/rows that reach the S2 go stopping boundary (including trials that continue to the end):
#     s2.go.bin <- apply(success.cum.nocurtail.at.s1, 1, function(x) any(x==s2.go))
#     s2.go.index <- which(s2.go.bin)
#     # Sample size of trials with a go decision:
#     s2.go.ss <- apply(success.cum.nocurtail.at.s1[s2.go.index, , drop=FALSE], 1, function(x) which.max(x==s2.go))
#     # Sample size of trials with a no go decision, conditional on not stopping in S1:
#     s2.nogo.ss <- apply(failure.cum.nocurtail.at.s1[-s2.go.index, , drop=FALSE], 1, function(x) which.max(x==s2.nogo))
#
#     ess <- sum(s1.curtailed.ss, s2.go.ss, s2.nogo.ss)/runs
#     prob.reject.h0 <- length(s2.go.ss)/runs
#     prob.accept.h0 <- (length(s2.nogo.ss)+length(s1.curtailed.ss))/runs
return(c(n1, n, a1, r2, prob.reject.h0, ess))
}
chen.typeI
chen.power
set.seed(1)
chen.typeIx <- chenSim(h0=TRUE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e5)
chen.typeIx
chen.typeIx <- chenSimX(h0=TRUE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e5)
chen.typeIx
length(early.stop.success.ss)
########### Function for single row: Chen #############
chenSimX <- function(h0, n1, n, a1, r2, pc, pt, runs){
n2 <- n-n1
# Stopping rules for S1 and S2:
s1.nogo <- n1-a1+1
s2.go <- n+r2
s2.nogo <- n-r2+1
# h0: Set TRUE to estimate type I error and ESS|pt=pc, set to FALSE for power and ESS|pt=pt
if(h0==TRUE){
pt <- pc
}
# Simulate all successes together, on trt and on control. "Success" means reponse if on trt, non-response if on control:
trt <- rbinom(n*runs, 1, prob=pt)
con <- rbinom(n*runs, 1, prob=1-pc)
##### Build matrix of successes, both stage 1 and stage 2 #####
# Allocate pats to trt or control. Note: Balance only required by end of trial.
alloc <- vector("list", runs)
n.times.i.minus.1 <- n*((1:runs)-1)
success.s12 <- matrix(rep(0, 2*n*runs), nrow=runs)
# TRUE for TREATMENT, FALSE for CONTROL:
for(i in 1:runs){
alloc[[i]] <- sample(rep(c(T, F), n), size=2*n, replace=F)
s.index <- (n.times.i.minus.1[i]+1):(n.times.i.minus.1[i]+n)
success.s12[i, alloc[[i]]] <-  trt[s.index]
success.s12[i,!alloc[[i]]] <-  con[s.index]
}
success <- success.s12
failure <- -1*(success-1)
# Cumulative successes and failures over time:
success.cum <- t(apply(success, 1, cumsum))
failure.cum <- t(apply(failure, 1, cumsum))
# Stage 1 only:
success.s1.cum <- success.cum[,1:(2*n1)]
failure.s1.cum <- failure.cum[,1:(2*n1)]
# Which trials fail early due to hitting n1-a1+1 failures?
fail.wrt.s1.boundary.index <- apply(failure.s1.cum, 1, function(x) any(x==s1.nogo))
curtailed.s1.subset <- failure.s1.cum[fail.wrt.s1.boundary.index, , drop=FALSE]
# Sample size of trials curtailed at S1:
s1.curtailed.ss <- apply(curtailed.s1.subset, 1, function(x) which.max(x==s1.nogo))
# Subset cumulative results to only the remaining trials:
success.cum.non.s1.failure.trials.subset <- success.cum[-fail.wrt.s1.boundary.index, , drop=FALSE]
failure.cum.non.s1.failure.trials.subset <- failure.cum[-fail.wrt.s1.boundary.index, , drop=FALSE]
# Of these remaining trials, which trials reach the req'd no. of successes, and after how many participants?
successful.trial.index <- apply(success.cum.non.s1.failure.trials.subset, 1, function(x) any(x==s2.go))
success.cum.successful.trials.subset <- success.cum.non.s1.failure.trials.subset[successful.trial.index, , drop=FALSE]
early.stop.success.ss <- apply(success.cum.successful.trials.subset, 1, function(x) which.max(x==s2.go))
# The remaining trials must fail by reaching the required no. of failures. After how many participants do the trials end?
failure.cum.s2.failure.trials.subset <- failure.cum.non.s1.failure.trials.subset[!successful.trial.index, , drop=FALSE]
early.stop.failure.ss <- apply(failure.cum.s2.failure.trials.subset, 1, function(x) which.max(x==s2.nogo))
# Find type I error, power, ESS:
prob.reject.h0 <- length(early.stop.success.ss)/runs
ess <- 0.5*sum(s1.curtailed.ss, early.stop.success.ss, early.stop.failure.ss)/runs
#
#     # Split into "curtailed during S1" and "not curtailed during S1". Note: curtail for no go only.
#     curtailed.s1.bin <- apply(failure.s1.cum, 1, function(x) any(x==s1.nogo))
#     curtailed.s1.index <- which(curtailed.s1.bin) # Index of trials/rows that reach the S1 no go stopping boundary
#     curtailed.s1.subset <- failure.s1.cum[curtailed.s1.index, , drop=FALSE]
#     # Sample size of trials curtailed at S1:
#     s1.curtailed.ss <- apply(curtailed.s1.subset, 1, function(x) which.max(x==s1.nogo))
#
#     ########## All other trials progress to S2. Subset these:
#     success.cum.nocurtail.at.s1 <- success.cum[-curtailed.s1.index, , drop=FALSE]
#     failure.cum.nocurtail.at.s1 <- failure.cum[-curtailed.s1.index, , drop=FALSE]
#
#     # Trials/rows that reach the S2 go stopping boundary (including trials that continue to the end):
#     s2.go.bin <- apply(success.cum.nocurtail.at.s1, 1, function(x) any(x==s2.go))
#     s2.go.index <- which(s2.go.bin)
#     # Sample size of trials with a go decision:
#     s2.go.ss <- apply(success.cum.nocurtail.at.s1[s2.go.index, , drop=FALSE], 1, function(x) which.max(x==s2.go))
#     # Sample size of trials with a no go decision, conditional on not stopping in S1:
#     s2.nogo.ss <- apply(failure.cum.nocurtail.at.s1[-s2.go.index, , drop=FALSE], 1, function(x) which.max(x==s2.nogo))
#
#     ess <- sum(s1.curtailed.ss, s2.go.ss, s2.nogo.ss)/runs
#     prob.reject.h0 <- length(s2.go.ss)/runs
#     prob.accept.h0 <- (length(s2.nogo.ss)+length(s1.curtailed.ss))/runs
return(c(n1, n, a1, r2, prob.reject.h0, ess))
}
set.seed(1)
chen.typeIx <- chenSimX(h0=TRUE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e5)
chen.typeIx
chen.typeI
chen.power
chen.powerx <- chenSimX(h0=FALSE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e5)
chen.powerx
########### Function for single row: Chen #############
chenSimX <- function(h0, n1, n, a1, r2, pc, pt, runs){
n2 <- n-n1
# Stopping rules for S1 and S2:
s1.nogo <- n1-a1+1
s2.go <- n+r2
s2.nogo <- n-r2+1
# h0: Set TRUE to estimate type I error and ESS|pt=pc, set to FALSE for power and ESS|pt=pt
if(h0==TRUE){
pt <- pc
}
# Simulate all successes together, on trt and on control. "Success" means reponse if on trt, non-response if on control:
trt <- rbinom(n*runs, 1, prob=pt)
con <- rbinom(n*runs, 1, prob=1-pc)
##### Build matrix of successes, both stage 1 and stage 2 #####
# Allocate pats to trt or control. Note: Balance only required by end of trial.
alloc <- vector("list", runs)
n.times.i.minus.1 <- n*((1:runs)-1)
success.s12 <- matrix(rep(0, 2*n*runs), nrow=runs)
# TRUE for TREATMENT, FALSE for CONTROL:
for(i in 1:runs){
alloc[[i]] <- sample(rep(c(T, F), n), size=2*n, replace=F)
s.index <- (n.times.i.minus.1[i]+1):(n.times.i.minus.1[i]+n)
success.s12[i, alloc[[i]]] <-  trt[s.index]
success.s12[i,!alloc[[i]]] <-  con[s.index]
}
success <- success.s12
failure <- -1*(success-1)
# Cumulative successes and failures over time:
success.cum <- t(apply(success, 1, cumsum))
failure.cum <- t(apply(failure, 1, cumsum))
# Stage 1 only:
success.s1.cum <- success.cum[,1:(2*n1)]
failure.s1.cum <- failure.cum[,1:(2*n1)]
# Which trials fail early due to hitting n1-a1+1 failures?
fail.wrt.s1.boundary.index <- apply(failure.s1.cum, 1, function(x) any(x==s1.nogo))
curtailed.s1.subset <- failure.s1.cum[fail.wrt.s1.boundary.index, , drop=FALSE]
# Sample size of trials curtailed at S1:
s1.curtailed.ss <- apply(curtailed.s1.subset, 1, function(x) which.max(x==s1.nogo))
# Subset cumulative results to only the remaining trials:
success.cum.non.s1.failure.trials.subset <- success.cum[-fail.wrt.s1.boundary.index, , drop=FALSE]
failure.cum.non.s1.failure.trials.subset <- failure.cum[-fail.wrt.s1.boundary.index, , drop=FALSE]
# Of these remaining trials, which trials reach the req'd no. of successes, and after how many participants?
successful.trial.index <- apply(success.cum.non.s1.failure.trials.subset, 1, function(x) any(x==s2.go))
success.cum.successful.trials.subset <- success.cum.non.s1.failure.trials.subset[successful.trial.index, , drop=FALSE]
early.stop.success.ss <- apply(success.cum.successful.trials.subset, 1, function(x) which.max(x==s2.go))
# The remaining trials must fail by reaching the required no. of failures. After how many participants do the trials end?
failure.cum.s2.failure.trials.subset <- failure.cum.non.s1.failure.trials.subset[!successful.trial.index, , drop=FALSE]
early.stop.failure.ss <- apply(failure.cum.s2.failure.trials.subset, 1, function(x) which.max(x==s2.nogo))
# Find type I error, power, ESS:
prob.reject.h0 <- length(early.stop.success.ss)/runs
ess <- 0.5*sum(s1.curtailed.ss, early.stop.success.ss, early.stop.failure.ss)/runs
#
#     # Split into "curtailed during S1" and "not curtailed during S1". Note: curtail for no go only.
#     curtailed.s1.bin <- apply(failure.s1.cum, 1, function(x) any(x==s1.nogo))
#     curtailed.s1.index <- which(curtailed.s1.bin) # Index of trials/rows that reach the S1 no go stopping boundary
#     curtailed.s1.subset <- failure.s1.cum[curtailed.s1.index, , drop=FALSE]
#     # Sample size of trials curtailed at S1:
#     s1.curtailed.ss <- apply(curtailed.s1.subset, 1, function(x) which.max(x==s1.nogo))
#
#     ########## All other trials progress to S2. Subset these:
#     success.cum.nocurtail.at.s1 <- success.cum[-curtailed.s1.index, , drop=FALSE]
#     failure.cum.nocurtail.at.s1 <- failure.cum[-curtailed.s1.index, , drop=FALSE]
#
#     # Trials/rows that reach the S2 go stopping boundary (including trials that continue to the end):
#     s2.go.bin <- apply(success.cum.nocurtail.at.s1, 1, function(x) any(x==s2.go))
#     s2.go.index <- which(s2.go.bin)
#     # Sample size of trials with a go decision:
#     s2.go.ss <- apply(success.cum.nocurtail.at.s1[s2.go.index, , drop=FALSE], 1, function(x) which.max(x==s2.go))
#     # Sample size of trials with a no go decision, conditional on not stopping in S1:
#     s2.nogo.ss <- apply(failure.cum.nocurtail.at.s1[-s2.go.index, , drop=FALSE], 1, function(x) which.max(x==s2.nogo))
#
#     ess <- sum(s1.curtailed.ss, s2.go.ss, s2.nogo.ss)/runs
#     prob.reject.h0 <- length(s2.go.ss)/runs
#     prob.accept.h0 <- (length(s2.nogo.ss)+length(s1.curtailed.ss))/runs
return(c(n1, n, a1, r2, prob.reject.h0, ess))
}
rm(h0,n1,n,a1,r2,pc,pt,runs)
set.seed(1)
chen.typeI <- chenSim(h0=TRUE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e6)
chen.power <- chenSim(h0=FALSE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e6)
set.seed(1)
chen.typeIx <- chenSimX(h0=TRUE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e6)
chen.powerx <- chenSimX(h0=FALSE, n1=12, n=27, a1=1, r2=4, pc=0.10, pt=0.40, runs=1e6)
chen.typeI
chen.typeIx
chen.power
chen.powerx
chenSim
#h0=FALSE; n1=12; n=27; a1=1; r2=4; pc=0.10; pt=0.40; runs=2
set.seed(1)
chen.typeI <- chenSim(h0=TRUE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e5)
chen.power <- chenSim(h0=FALSE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e5)
set.seed(1)
chen.typeIx <- chenSimX(h0=TRUE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e5)
chen.powerx <- chenSimX(h0=FALSE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e5)
chen.typeI
chen.typeIx
chen.power
chen.powerx
set.seed(1)
chen.typeI <- chenSim(h0=TRUE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e6)
chen.power <- chenSim(h0=FALSE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e6)
#h0=FALSE; n1=12; n=27; a1=1; r2=4; pc=0.10; pt=0.40; runs=2
set.seed(10)
chen.typeI <- chenSim(h0=TRUE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e6)
chen.power <- chenSim(h0=FALSE, n1=21, n=37, a1=2, r2=6, pc=0.2, pt=0.5, runs=1e6)
chen.typeI
chen.power
chen.typeIx
chen.powerx
block8.opt <- curtailment::twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
block8.opt <- curtailment::twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
debug(twoarmDesign)
block8.opt <- curtailment::twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
twoarmDesign
source("R/2arm_1-reproduce-results-functions-find-designs.R")
debug(twoarmDesign)
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
undebug(twoarmDesign)
source("R/2arm_1-reproduce-results-functions-find-designs.R")
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
1:nrow(sc.subset)
sc.subset
data.frame(n=ns, r=unlist(r.list))
bounds
fixed.r
sc.subset <- data.frame(n=ns, r=unlist(r.list))
sc.subset
if(!is.null(bounds)){
# Incorporate A'Hern's bounds:
if(bounds=="ahern")  {
#sc.subset <- sc.subset[sc.subset$r >= pc*sc.subset$n & sc.subset$r <= pt*sc.subset$n, ] # One-arm case
sc.subset <- sc.subset[sc.subset$r >= 1 & sc.subset$r <= pt*sc.subset$n, ] # Try this for two-arm case -- interval [1, pt*Narm]
}
if(bounds=="wald"){
# Even better to incorporate Wald's bounds:
denom <- log(pt/pc) - log((1-pt)/(1-pc))
accept.null <- log((1-power)/(1-alpha)) / denom  + nposs * log((1-pc)/(1-pt))/denom
accept.null <- floor(accept.null)
reject.null <- log((power)/alpha) / denom  + nposs * log((1-pc)/(1-pt))/denom
reject.null <- ceiling(reject.null)
r.wald <- NULL
ns.wald <- NULL
for(i in 1:length(nposs)){
r.wald <- c(r.wald, accept.null[i]:reject.null[i])
ns.wald <- c(ns.wald, rep(nposs[i], length(accept.null[i]:reject.null[i])))
}
sc.subset <- data.frame(n=ns.wald, r=r.wald)
sc.subset <- sc.subset[sc.subset$n - sc.subset$r >=2, ]
}
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
sc.subset <- data.frame(n=ns, r=unlist(r.list))
sc.subset
if(!is.null(bounds)){
# Incorporate A'Hern's bounds:
if(bounds=="ahern")  {
#sc.subset <- sc.subset[sc.subset$r >= pc*sc.subset$n & sc.subset$r <= pt*sc.subset$n, ] # One-arm case
sc.subset <- sc.subset[sc.subset$r >= 1 & sc.subset$r <= pt*sc.subset$n, ] # Try this for two-arm case -- interval [1, pt*Narm]
}
if(bounds=="wald"){
# Even better to incorporate Wald's bounds:
denom <- log(pt/pc) - log((1-pt)/(1-pc))
accept.null <- log((1-power)/(1-alpha)) / denom  + nposs * log((1-pc)/(1-pt))/denom
accept.null <- floor(accept.null)
reject.null <- log((power)/alpha) / denom  + nposs * log((1-pc)/(1-pt))/denom
reject.null <- ceiling(reject.null)
r.wald <- NULL
ns.wald <- NULL
for(i in 1:length(nposs)){
r.wald <- c(r.wald, accept.null[i]:reject.null[i])
ns.wald <- c(ns.wald, rep(nposs[i], length(accept.null[i]:reject.null[i])))
}
sc.subset <- data.frame(n=ns.wald, r=r.wald)
sc.subset <- sc.subset[sc.subset$n - sc.subset$r >=2, ]
}
undebug(twoarmDesign)
source("R/2arm_1-reproduce-results-functions-find-designs.R")
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
sc.subset <- data.frame(n=ns, r=unlist(r.list))
denom <- log(pt/pc) - log((1-pt)/(1-pc))
accept.null <- log((1-power)/(1-alpha)) / denom  + nposs * log((1-pc)/(1-pt))/denom
accept.null <- floor(accept.null)
reject.null <- log((power)/alpha) / denom  + nposs * log((1-pc)/(1-pt))/denom
reject.null <- ceiling(reject.null)
r.wald <- NULL
ns.wald <- NULL
for(i in 1:length(nposs)){
r.wald <- c(r.wald, accept.null[i]:reject.null[i])
ns.wald <- c(ns.wald, rep(nposs[i], length(accept.null[i]:reject.null[i])))
}
sc.subset <- data.frame(n=ns.wald, r=r.wald)
sc.subset <- sc.subset[sc.subset$n - sc.subset$r >=2, ]
source("R/2arm_1-reproduce-results-functions-find-designs.R")
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
sc.subset
source("R/2arm_1-reproduce-results-functions-find-designs.R")
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
sc.subset
source("R/2arm_1-reproduce-results-functions-find-designs.R")
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,
exact.thetaF=0.3005, exact.thetaE=0.97)
block8.opt
block8.opt <- twoarmDesign(nmin.arm=112/2, nmax.arm=112/2, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8,fixed.r=5,bounds=NULL,
exact.thetaF=0.3005, exact.thetaE=0.97)
block8.mini <- curtailment::twoarmDesign(nmin.arm=40, nmax.arm=40, block.size=8, pc=0.3,
pt=0.5, alpha=0.15, power=0.8, bounds="ahern", fixed.r=4,
exact.thetaF=0.0609, exact.thetaE=0.9752)
drawDiagram(block8.mini)
curtailment::drawDiagram(block8.mini)
block8.mini
curtailment::drawDiagram(block8.mini)
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F)
debug(createPlotAndBounds2arm)
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F)
initial.stop.bounds
undebug(createPlotAndBounds2arm)
debug(findBounds)
findBounds(des=block8.mini$all.des, des.input=block8.mini$input)
mat
des.input
des
findBounds <- function(des, des.input){
Bsize <- des.input$block
mat <- findBlockCP(n=des$n.arm,
r=des$r,
Bsize=Bsize,
pc=des.input$pc,
pt=des.input$pt,
thetaF=des$thetaF,
thetaE=des$thetaE)
boundaries <- matrix(NA, nrow=2, ncol=ncol(mat)/Bsize)
rownames(boundaries) <- c("lower", "upper")
interims <- seq(from=Bsize, to=ncol(mat), by=Bsize)
colnames(boundaries) <- paste(interims)
for(i in 1:length(interims)){
j <- interims[i]
lower <- if (any(mat[,j]==0, na.rm=TRUE) ) max(which(mat[,j]==0))-1 else -Inf
upper <- if (any(mat[,j]==1, na.rm=TRUE) ) which.max(mat[,j])-1 else Inf
# -1 terms to account for the fact that row 1 is equivalent to zero successes.
boundaries[, i] <- c(lower, upper)
}
return(boundaries)
}
source("R/2arm_1-reproduce-results-functions-find-designs.R")
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F)
findBounds(des=block8.mini$all.des, des.input=block8.mini$input)
debug(createPlotAndBounds2arm)
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F)
initial.stop.bounds
undebug(createPlotAndBounds2arm)
createPlotAndBounds2arm <- function(des, des.input, rownum, save.plot, xmax, ymax){
rownum <- as.numeric(rownum)
des <- des[rownum, , drop=FALSE]
initial.stop.bounds <- findBounds(des=des,
des.input=des.input)
initial.stop.bounds <- data.frame(t(initial.stop.bounds))
initial.stop.bounds <- cbind(as.numeric(rownames(initial.stop.bounds)), initial.stop.bounds)
names(initial.stop.bounds) <- c("m", "fail", "success")
tp.fail.components <- apply(initial.stop.bounds[!is.infinite(initial.stop.bounds$fail),], 1, function(x) data.frame(0:x["fail"], rep(x["m"], length(0:x["fail"]))))
tp.fail <- do.call(rbind, tp.fail.components)
names(tp.fail) <- c("Sm", "m")
tp.success.components <- apply(initial.stop.bounds[!is.infinite(initial.stop.bounds$success),], 1, function(x) data.frame(x["success"]:x["m"], rep(x["m"], length(x["success"]:x["m"]))))
tp.success <- do.call(rbind, tp.success.components)
names(tp.success) <- c("Sm", "m")
coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
# for(i in 1:nrow(tp.success.unneeded)){
#   unneeded.success.index <- diag.df$Sm==tp.success.unneeded$Sm[i] & diag.df$m==tp.success.unneeded$m[i]
#   diag.df$decision[unneeded.success.index] <- NA
# }
# Add shading:
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
stop.index <- diag.df.subset$m %in% initial.stop.bounds$m
diag.df.subset$analysis[stop.index] <- "Yes"
plot.title <- "Stopping boundaries"
sub.text1 <- paste("Max no. of analyses: ", des$stage, ". Max(N): ", des$n, ". ESS(p", sep="")
sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
sub.text3 <- paste("):", round(des$Ess, 1), sep="")
plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses on treatment + non-responses on control",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
xbreaks <- seq(from=des.input$block, to=des$n, by=des.input$block)
if(!is.null(xmax)){
diagram <- diagram +
expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
expand_limits(y=ymax)
}
diagram <- diagram +
scale_x_continuous(breaks=xbreaks)+
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
print(diagram)
if(save.plot==TRUE){
save.plot.yn <- readline("Save plot? (y/n): ")
if(save.plot.yn=="y"){
plot.filename <- readline("enter filename (no special characters or inverted commas): ")
plot.filename <- paste(plot.filename, ".pdf", sep="")
plot.width <- 8
scaling <- 1.25
plot.height <- 8*scaling*(des$r+1)/des$n
pdf(plot.filename, width = plot.width, height = plot.height)
print(diagram)
dev.off()
}
tp.success.unique.m <- tp.success[!duplicated(tp.success$m), ]
stop.bounds <- data.frame(m=seq(from=des$block, to=des$n, by=des$block),
success=Inf,
fail=-Inf)
stop.bounds$success[match(tp.success.unique.m$m, stop.bounds$m)] <- tp.success.unique.m$Sm
stop.bounds$fail[match(tp.fail$m, stop.bounds$m)] <- tp.fail$Sm
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F)
library(ggplot2)
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F)
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F, xmax=80)
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F, xmax=80, ymax=80)
createPlotAndBounds2arm(des=block8.mini$all.des, des.input=block8.mini$input, rownum=1, save.plot=F, xmax=80, ymax=55)
curtailment::drawDiagram(block8.opt)
curtailment::drawDiagram(block8.mini)
209/365
94*0.57
