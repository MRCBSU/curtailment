coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
fails.sm <- c(0:des$r1, (des$r1+1):des$r)
# fails.m <- c(rep(des$n1, length(0:des$r1)),
#              rep(des$n, length((des$r1+1):des$r))
#              )
fails.m <- c((des$n1-des$r1):des$n1,
seq(to=des$n, length=des$r-des$r1))
tp.fail <- data.frame(Sm=fails.sm,
m=fails.m)
# tp.success <- data.frame(Sm=(des$r+1):des$n,
#                          m=rep(des$n, length((des$r+1):des$n))
#                          )
tp.success <- data.frame(Sm=rep(des$r+1, des$n-des$r),
m=(des$r+1):des$n
)
# If stopping for benefit:
# if("e1" %in% names(des)){
#   tp.success.s1 <- data.frame(Sm=(des$e1+1):des$n1,
#                               m=rep(des$n1, length((des$e1+1):des$n1))
#                               )
#   tp.success <- rbind(tp.success, tp.success.s1)
# }
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
#diag.df.subset$analysis[diag.df.subset$m %in% tp.fail$m] <- "Yes"
diag.df.subset$analysis[diag.df.subset$m %in% c(tp.fail$m, tp.success$m)] <- "Yes"
plot.title <- "Stopping boundaries"
sub.text1 <- paste("Max no. of analyses: 2. Max(N): ", des$n, ". ESS(p", sep="")
sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
sub.text3 <- paste("):", round(des$Ess, 1), sep="")
plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
xbreaks <- c(des$n1, des$n)
if(!is.null(xmax)){
diagram <- diagram +
expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
expand_limits(y=ymax)
}
diagram <- diagram +
scale_x_continuous(breaks=xbreaks)+
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
print(diagram)
if(save.plot==TRUE){
save.plot.yn <- readline("Save plot? (y/n): ")
if(save.plot.yn=="y"){
plot.filename <- readline("enter filename (no special characters or inverted commas): ")
plot.filename <- paste(plot.filename, ".pdf", sep="")
plot.width <- 8
scaling <- 1.25
plot.height <- 8*scaling*(des$r+1)/des$n
pdf(plot.filename, width = plot.width, height = plot.height)
print(diagram)
dev.off()
}
tp.success.unique.m <- tp.success[!duplicated(tp.success$m), ]
stop.bounds <- data.frame(m=sort(union(tp.fail$m, tp.success$m)),
success=Inf,
fail=-Inf)
stop.bounds$success[match(tp.success$m, stop.bounds$m)] <- tp.success$Sm
stop.bounds$fail[match(tp.fail$m, stop.bounds$m)] <- tp.fail$Sm
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
createPlotAndBoundsSimonNSCreview(des=x3)
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram
diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
diagram
diagram + labs(title="XX")
diagram + labs(title="")
diagram + labs(title="", subtitle="")
diagram
diag.df.subset
diagram
points <- data.frame(x=1:5, y=c(0,0,1,1,2))
points
diagram+
geom_point(data=points, mapping=aes(x=x, y=y))
diagram+
geom_point(data=points, mapping=aes(x=x, y=y))
diagram
diagram+
geom_point(data=points, mapping=aes(x=x, y=y), inherit.aes=FALSE)
path.df <- data.frame(x=1:16,
y=c(0,0,0,0,1,1,1,1,1,1,1,1,2,3,3,3))
diagram+
geom_point(data=points, mapping=aes(x=x, y=y), inherit.aes=FALSE)
diagram+
geom_point(data=path.df, mapping=aes(x=x, y=y), inherit.aes=FALSE)
x3 <- findSingleSimonDesign(n1=19,n2=39,r1=6,r2=15,p0=0.3,p1=0.5)
x3
s1 <- findSimonDesigns(nmin=39,nmax=39,p0=0.3,p1=0.5,alpha=0.31,power=0.9)
s1
x3 <- findSingleSimonDesign(n1=19,n2=39,r1=6,r2=15,p0=0.3,p1=0.5)
x3
class(x3)
as.data.frame(x3)
as.data.frame(x3[1, ])
x3
dim(x3)
x3
as.data.frame(t(x3))
createPlotAndBoundsSimonReview <- function(des, save.plot=FALSE, xmax=NULL, ymax=NULL){
des <- as.data.frame(t(des))
coords <- expand.grid(0:des$n, 1:des$n)
diag.df <- data.frame(Sm=as.numeric(coords[,1]),
m=as.numeric(coords[,2]),
decision=rep("Continue", nrow(coords)))
diag.df$decision <- as.character(diag.df$decision)
diag.df$decision[coords[,1]>coords[,2]] <- NA
fails.sm <- c(0:des$r1, (des$r1+1):des$r)
fails.m <- c(rep(des$n1, length(0:des$r1)),
rep(des$n, length((des$r1+1):des$r))
)
tp.fail <- data.frame(Sm=fails.sm,
m=fails.m)
tp.success <- data.frame(Sm=(des$r+1):des$n,
m=rep(des$n, length((des$r+1):des$n))
)
# If stopping for benefit:
if("e1" %in% names(des)){
tp.success.s1 <- data.frame(Sm=(des$e1+1):des$n1,
m=rep(des$n1, length((des$e1+1):des$n1))
)
tp.success <- rbind(tp.success, tp.success.s1)
}
success.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.success$Sm & as.numeric(y[2])==tp.success$m))
diag.df$decision[success.index] <- "Go decision"
fail.index <- apply(diag.df, 1, function(y) any(as.numeric(y[1])==tp.fail$Sm & as.numeric(y[2])==tp.fail$m))
diag.df$decision[fail.index] <- "No go decision"
for(i in 1:nrow(tp.fail)){
not.poss.fail.index <- diag.df$Sm==tp.fail$Sm[i] & diag.df$m>tp.fail$m[i]
diag.df$decision[not.poss.fail.index] <- NA
}
for(i in 1:nrow(tp.success)){
not.poss.pass.index <- diag.df$m-diag.df$Sm==tp.success$m[i]-tp.success$Sm[i] & diag.df$m>tp.success$m[i]
diag.df$decision[not.poss.pass.index] <- NA
}
diag.df.subset <- diag.df[!is.na(diag.df$decision),]
diag.df.subset$analysis <- "No"
diag.df.subset$analysis[diag.df.subset$m %in% tp.fail$m] <- "Yes"
plot.title <- "Stopping boundaries"
sub.text1 <- paste("Max no. of analyses: 2. Max(N): ", des$n, ". ESS(p", sep="")
sub.text2 <- paste("): ", round(des$EssH0, 1), ". ESS(p", sep="")
sub.text3 <- paste("):", round(des$Ess, 1), sep="")
plot.subtitle2 <- bquote(.(sub.text1)[0]*.(sub.text2)[1]*.(sub.text3))
diagram <- pkgcond::suppress_warnings(ggplot2::ggplot(data=diag.df.subset, mapping = aes(x=m, y=Sm, fill=decision, alpha=analysis))+
scale_alpha_discrete(range=c(0.5, 1)),
"Using alpha for a discrete variable is not advised")
diagram <- diagram +
geom_tile(color="white")+
labs(fill="Decision",
alpha="Analysis",
x="Number of participants",
y="Number of responses",
title=plot.title,
subtitle = plot.subtitle2)+
coord_cartesian(expand = 0)+
theme_minimal()
xbreaks <- c(des$n1, des$n)
if(!is.null(xmax)){
diagram <- diagram +
expand_limits(x=xmax)
xbreaks <- c(xbreaks, xmax)
}
if(!is.null(ymax)){
diagram <- diagram +
expand_limits(y=ymax)
}
diagram <- diagram +
scale_x_continuous(breaks=xbreaks)+
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))))
print(diagram)
if(save.plot==TRUE){
save.plot.yn <- readline("Save plot? (y/n): ")
if(save.plot.yn=="y"){
plot.filename <- readline("enter filename (no special characters or inverted commas): ")
plot.filename <- paste(plot.filename, ".pdf", sep="")
plot.width <- 8
scaling <- 1.25
plot.height <- 8*scaling*(des$r+1)/des$n
pdf(plot.filename, width = plot.width, height = plot.height)
print(diagram)
dev.off()
}
stop.bounds <- data.frame(m=c(des$n1, des$n),
success=c(Inf, des$r+1),
fail=c(des$r1, des$r))
return(list(diagram=diagram,
bounds.mat=stop.bounds))
}
createPlotAndBoundsSimonReview(des=x3)
createPlotAndBoundsSimonNSCreview(des=x3)
x3 <- findSingleSimonDesign(n1=19,n2=39-19,r1=6,r2=15,p0=0.3,p1=0.5)
createPlotAndBoundsSimonReview(des=x3)
createPlotAndBoundsSimonNSCreview(des=x3, )
createPlotAndBoundsSimonNSCreview(des=x3, ymax=39)
createPlotAndBoundsSimonReview(des=x3)
createPlotAndBoundsSimonNSCreview(des=x3, ymax=39)
x <- createPlotAndBoundsSimonReview(des=x3)
xx <- createPlotAndBoundsSimonNSCreview(des=x3, ymax=39)
x
x+
geom_point(data=path.df, mapping=aes(x=x, y=y), inherit.aes=FALSE)
x$diagram+
geom_point(data=path.df, mapping=aes(x=x, y=y), inherit.aes=FALSE)
# When you add documentation in the function file, run devtools::document() and roxygen will convert it into "real" documentation:
devtools::document()
# When you add documentation in the function file, run devtools::document() and roxygen will convert it into "real" documentation:
devtools::document()
rm(list=ls())
# When you add documentation in the function file, run devtools::document() and roxygen will convert it into "real" documentation:
devtools::document()
# When you add documentation in the function file, run devtools::document() and roxygen will convert it into "real" documentation:
devtools::document()
library(curtailment)
x <- singlearmDesign(nmin=40,nmax=40,stages=4,p0=0.1,p1=0.4,alpha=0.2,power=0.8)
x
################ Function for finding the uncurtailed CP matrix:
findBlock2armUncurtailedMatrix <- function(n, r, Bsize, pat.cols, prob.vec){
cpmat <- matrix(3, ncol=2*n, nrow=min(n+r+Bsize+2, 2*n+1))
rownames(cpmat) <- 0:(nrow(cpmat)-1)
cpmat[(n+r+2):nrow(cpmat),] <- 1
cpmat[1:(n+r+1),2*n] <- 0 # Fail at end
for(i in (n+r+1):1){
for(j in pat.cols){  # Only look every C patients (no need to look at final col)
if(i-1<=j){ # Condition: Sm<=m
cpmat[i,j] <- ifelse(test=j-(i-1) >= n-r+1, yes=0, no=sum(prob.vec*cpmat[i:(i+Bsize), j+Bsize]))
# IF success is not possible (i.e. [total no. of pats-Xa+Ya-Xb] >= n-r+1), THEN set CP to zero. Otherwise, calculate it based on "future" CPs.
}
for(i in 3:nrow(cpmat)){
cpmat[i, 1:(i-2)] <- NA
}
cpmat
}
################ Function for finding the Prob(reponses on treatment + non-responses on control)=0, 1, 2,... Bsize:
findProbVec <- function(Bsize, pt=pt, qt=qt, pc=pc, qc=qc){
prob.vec <- rep(NA, Bsize+1)
for(i in 1:(Bsize+1)){
positives <- i-1
full.vec <- expand.grid(rep(list(0:1), Bsize))
positive.mat <- full.vec[rowSums(full.vec) == positives,]
negative.mat <- -1*(positive.mat-1)
positive.vec <- rep(c(pt,qc), each=Bsize/2)
negative.vec <- rep(c(qt,pc), each=Bsize/2)
posneg.mat <- t(t(positive.mat)*positive.vec) + t(t(negative.mat)*negative.vec)
prob.vec[i] <- sum(apply(posneg.mat, 1, prod))
}
if(sum(prob.vec)-1 > 1e-8) stop("Probabilities do not sum to 1.")
prob.vec
}
# two-arm work:
prob.vec <- findProbVec(Bsize=2, pt=0.4, qt=1-0.4, pc=0.1, qc=1-0.1)
prob.vec
# two-arm work:
Bsize <- 2
n <- 40
seq(from=2*n, to=Bsize, by=-Bsize)
n <- 20
seq(from=2*n, to=Bsize, by=-Bsize)
seq(from=2*n, to=Bsize, by=-Bsize)[-1]
pat.cols <- seq(from=2*n, to=Bsize, by=-Bsize)[-1]
findBlock2armUncurtailedMatrix(n=40, r=10, Bsize=Bsize, pat.cols=pat.cols, prob.vec=prob.vec)
findBlock2armUncurtailedMatrix(n=20, r=5, Bsize=Bsize, pat.cols=pat.cols, prob.vec=prob.vec)
x <- findBlock2armUncurtailedMatrix(n=20, r=5, Bsize=Bsize, pat.cols=pat.cols, prob.vec=prob.vec)
x
x[5:28,]
x <- findBlock2armUncurtailedMatrix(n=20, r=6, Bsize=Bsize, pat.cols=pat.cols, prob.vec=prob.vec)
x[5:28, ]
x[5:29, ]
x[5:30, ]
x[20:30, ]
library(BurStMisc)
getwd()
x <- scriptSearch("Jung",  subdirs=TRUE, commentsIncluded=T, verbose = T)
x
setwd("~/PhD/twoarmSC-save")
x <- scriptSearch("mjg",  subdirs=TRUE, commentsIncluded=T, verbose = T)
x
setwd("~/PhD/twoarmSC")
x <- scriptSearch("mjg",  subdirs=TRUE, commentsIncluded=T, verbose = T)
x
setwd("~/PhD/twoarm")
x <- scriptSearch("mjg",  subdirs=TRUE, commentsIncluded=T, verbose = T)
x
x <- scriptSearch("Jung",  subdirs=TRUE, commentsIncluded=T, verbose = T)
x
findSingle2arm2stageJungDesignFast <- function(n1, n2, n, a1, r2, p0, p1, alpha, power){
#print(paste(n, n1, n2), q=F)
k1 <- a1:n1
y1.list <- list()
for(i in 1:length(k1)){
y1.list[[i]] <- max(0, -k1[i]):(n1-max(0, k1[i]))
}
k1 <- rep(k1, sapply(y1.list, length))
y1 <- unlist(y1.list)
combns <- cbind(k1, y1)
colnames(combns) <- c("k1", "y1")
rownames(combns) <- 1:nrow(combns)
k2.list <- vector("list", length(k1))
for(i in 1:length(k1)){
k2.list[[i]] <- (r2-k1[i]):n2
}
combns2 <- combns[rep(row.names(combns), sapply(k2.list, length)), , drop=FALSE] # duplicate each row so that there are sufficient rows for each a1 value
k2 <- unlist(k2.list)
combns2 <- cbind(combns2, k2)
rownames(combns2) <- 1:nrow(combns2)
y2.list <- vector("list", length(k2))
for(i in 1:length(k2)){
current.k2 <- -k2[i]
y2.list[[i]] <- max(0, current.k2):(n2-max(0, current.k2))
}
y2 <- unlist(y2.list)
combns3 <- combns2[rep(row.names(combns2), sapply(y2.list, length)), , drop=FALSE] # duplicate each row so that there are sufficient rows for each a1 value
all.combns <- cbind(combns3, y2)
# Convert to vectors for speed:
k1.vec <- all.combns[,"k1"]
y1.vec <- all.combns[,"y1"]
k2.vec <- all.combns[,"k2"]
y2.vec <- all.combns[,"y2"]
# Easier to understand, but slower:
part1 <- choose(n1, y1.vec)*p0^y1.vec*(1-p0)^(n1-y1.vec) * choose(n2, y2.vec)*p0^y2.vec*(1-p0)^(n2-y2.vec)
typeIerr <- sum(part1 * choose(n1, k1.vec+y1.vec)*p0^(k1.vec+y1.vec)*(1-p0)^(n1-(k1.vec+y1.vec)) * choose(n2, k2.vec+y2.vec)*p0^(k2.vec+y2.vec)*(1-p0)^(n2-(k2.vec+y2.vec)))
pwr <- sum(part1 * choose(n1, k1.vec+y1.vec)*p1^(k1.vec+y1.vec)*(1-p1)^(n1-(k1.vec+y1.vec)) * choose(n2, k2.vec+y2.vec)*p1^(k2.vec+y2.vec)*(1-p1)^(n2-(k2.vec+y2.vec)))
# Harder to understand, but faster:
# q0 <- 1-p0
# q1 <- 1-p1
# n1.minus.y1 <- n1-y1.vec
# n2.minus.y2 <- n1-y1.vec
# k1.plus.y1 <- k1.vec+y1.vec
# k2.plus.y2 <- k2.vec+y2.vec
# n1.minus.k1.and.y1 <- n1-k1.plus.y1
# n2.minus.k2.and.y2 <- n2-k2.plus.y2
# choose.n1.k1.plus.y1 <- choose(n1, k1.plus.y1)
# choose.n2.k2.plus.y2 <- choose(n2, k2.plus.y2)
#
# part1 <- choose(n1, y1.vec)*p0^y1.vec*q0^n1.minus.y1 * choose(n2, y2.vec)*p0^y2.vec*q0^n2.minus.y2 * choose.n1.k1.plus.y1 * choose.n2.k2.plus.y2
# typeIerr <- sum(part1 * p0^k1.plus.y1*q0^n1.minus.k1.and.y1 * p0^k2.plus.y2*q0^n2.minus.k2.and.y2)
# pwr <- sum(part1 * p1^k1.plus.y1*q1^n1.minus.k1.and.y1 * p1^k2.plus.y2*q1^n2.minus.k2.and.y2)
# Find ESS under H0 and H1:
if(typeIerr<=alpha & pwr>=power){
k11 <- -n1:(a1-1)
y11.list <- vector("list", length(k11))
for(i in 1:length(k11)){
y11.list[[i]] <- max(0, -k11[i]):(n1-max(0, k11[i]))
}
k11.vec <- rep(k11, sapply(y11.list, length))
y11.vec <- unlist(y11.list)
petH0 <- sum(choose(n1, y11.vec)*p0^y11.vec*(1-p0)^(n1-y11.vec) * choose(n1, k11.vec+y11.vec)*p0^(k11.vec+y11.vec)*(1-p0)^(n1-(k11.vec+y11.vec)))
petH1 <- sum(choose(n1, y11.vec)*p1^y11.vec*(1-p1)^(n1-y11.vec) * choose(n1, k11.vec+y11.vec)*p1^(k11.vec+y11.vec)*(1-p1)^(n1-(k11.vec+y11.vec)))
# choose.n1.y11 <- choose(n1, y11.vec)
# n1.minus.y11 <- n1-y11.vec
# choose.k11.y11 <- choose(n1, k11.vec+y11.vec)
# k11.y11 <- k11.vec+y11.vec
# n1.minus.k11.y11 <- n1-k11.y11
#
# pet.part1 <- choose.n1.y11 * choose.k11.y11
# petH0 <- sum(pet.part1 * p0^y11.vec*q0^n1.minus.y11 * p0^k11.y11*q0^n1.minus.k11.y11)
# petH1 <- sum(pet.part1 * p1^y11.vec*q1^n1.minus.y11 * p1^k11.y11*q1^n1.minus.k11.y11)
essH0 <- n1*petH0 + n*(1-petH0)
essH1 <- n1*petH1 + n*(1-petH1)
return(c(n1, n2, n, a1, r2, typeIerr, pwr, essH0, essH1))
} else {
return(c(n1, n2, n, a1, r2, typeIerr, pwr, NA, NA))
}
# Designs for Jung:
# From Jung's paper:
# Minimax: (n1, n, a1, a)=31, 63, -1, 6) EN=52.16 ie 104.32
# H0-optimal: (n1, n, a1, a)=(27, 73, 1, 6) EN=47.28 ie 94.56
# load("ex1_jung.RData")
jung.mini <- findSingle2arm2stageJungDesignFast(n1=31, n2=63-31, n=63, a1=-1, r2=6, p0=0.7, p1=0.85, alpha=0.15, power=0.8)
jung.mini
pc <- c(0.1, 0.2, 0.3, 0.4, 0.5)
pt <- pc+0.2
jung <- vector("list", 5)
jungtime <- system.time({
for(i in 1:5){
jung[[i]] <- des_comp(J = 2,
type = "binomial",
alpha = 0.15,
beta = 0.2,
delta = 0.2,
pi_null = pc[i],
pi_alt = pc[i],
two_stage = list(equal = F,
w=c(1, 0, 0, 0, 0),
pi_ess = pc[i],
efficacy = F,
futility = T))$feasible
}
}) # 5 mins
library(ph2rand)
pc <- c(0.1, 0.2, 0.3, 0.4, 0.5)
pt <- pc+0.2
jung <- vector("list", 5)
jungtime <- system.time({
for(i in 1:5){
jung[[i]] <- des_comp(J = 2,
type = "binomial",
alpha = 0.15,
beta = 0.2,
delta = 0.2,
pi_null = pc[i],
pi_alt = pc[i],
two_stage = list(equal = F,
w=c(1, 0, 0, 0, 0),
pi_ess = pc[i],
efficacy = F,
futility = T))$feasible
}
}) # 5 mins
?ph2rand
# Old code for Jung two-arm:
pc <- 0.3
pt <- 0.5
jungtime <- system.time({
jung <- des_comp(type = "binomial",
alpha = 0.15,
beta = 0.2,
delta = 0.2,
Pi0 = pc[i],
Pi1 = pc[i],
equal = F,
w=c(1, 0, 0, 0, 0),
efficacy = F,
futility = T,
summary=T)
}) # 5 mins
jungtime <- system.time({
jung <- des_two_stage(type = "binomial",
alpha = 0.15,
beta = 0.2,
delta = 0.2,
Pi0 = pc[i],
Pi1 = pc[i],
equal = F,
w=c(1, 0, 0, 0, 0),
efficacy = F,
futility = T,
summary=T)
}) # 5 mins
jung
jung$feasible
i
jungtime <- system.time({
jung <- des_two_stage(type = "binomial",
alpha = 0.15,
beta = 0.2,
delta = 0.2,
Pi0 = 0.3,
Pi1 = 0.3,
equal = F,
w=c(0, 1, 0, 0, 0),
efficacy = F,
futility = T,
summary=T)
}) # 5 mins
jung
