remove.packages("xfun", lib="\\bliss-03-nfs/homes/martin/Documents/R/win-library/3.6")
library(xfun)
install.packages("//bliss-03-nfs/homes/martin/xfun_0.24.zip", repos = NULL, type = "win.binary")
library(xfun)
library(rmarkdown)
setwd("H:/Nof1/Bayesian-bandit-adaptive-n-of-1-master/Bayesian-bandit-adaptive-n-of-1-master")
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 4,             # number of Markov chains
warmup = 4000,          # number of warmup iterations per chain
iter = 6000,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
source("AGGBAN_run.R")
source("INDBAN_run.R")
source("B_BAN_run.R")
source("FRN_run.R")
#population parameters
set.seed(2356)
tru.b.mu = c(7,-1) #population mean
tru.b.sig = c(1,3) #standard deviation suggesting between-patient variation
tru.y.sig = 2 #within-patient deviance
J = 3 #number of patients
nperiod = 4 #number of periods (two per cycle)
nobv = 2 #number of observations per patient
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 2,             # number of Markov chains
warmup = 40,          # number of warmup iterations per chain
iter = 60,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
#indiv parameters
b0 = rnorm(J,tru.b.mu[1],tru.b.sig[1])
b1 = rnorm(J,tru.b.mu[2],tru.b.sig[2])
b = cbind(b0,b1)
trup = c(tru.b.mu,tru.b.sig,tru.y.sig,b0,b1)
set.seed(NULL) #undo seed setting
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
install.packages("rstan", type = "win.binary", dependencies = TRUE)
install.packages("rstan", type = "win.binary", dependencies = TRUE)
install.packages( "https://win-builder.r-project.org/9256KcZ01L9C/StanHeaders_2.19.2.zip", repos = NULL, type = "win.binary")
#indiv parameters
b0 = rnorm(J,tru.b.mu[1],tru.b.sig[1])
b1 = rnorm(J,tru.b.mu[2],tru.b.sig[2])
b = cbind(b0,b1)
trup = c(tru.b.mu,tru.b.sig,tru.y.sig,b0,b1)
set.seed(NULL) #undo seed setting
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 2,             # number of Markov chains
warmup = 40,          # number of warmup iterations per chain
iter = 60,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
J = 3 #number of patients
nperiod = 4 #number of periods (two per cycle)
nobv = 2 #number of observations per patient
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
install.packages(c("rstan","StanHeaders"),type="source")
install.packages(c("rstan", "StanHeaders"), type = "source")
install.packages(c("rstan","StanHeaders"),type="source")
install.packages("StanHeaders", type="source")
AGGBAN_run <- function(J, nperiod, nobv, b, truep){
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
hmc_samples <- function(current_data){
hmodel <- stan_model(file='model_agg.stan') #stan model specified in an external file
houtput <- sampling(hmodel,
data = current_data,
chains = 2,             # number of Markov chains
warmup = 40,          # number of warmup iterations per chain
iter = 60,           # total number of iterations per chain
refresh = 0,
verbose = FALSE,
control = list(adapt_delta = 0.99, max_treedepth = 15))
return(houtput)
}
N = 2*J*nobv #number of total datapoints
t = y = id = period = cyc = array(0,N)
count = 0
#first cycle of treatments
for (i in 1:J){
tr1 = sample(c(0,1),1)  #decide which treatment to choose randomly
tr2 = 1-tr1   #ensure the other treatment is chosen next
Trt = c(tr1,tr2)
for (j in 1:length(Trt)){
for (z in 1:nobv){
count = count + 1
y[count] = b[i,1] + b[i,2]*Trt[j] + rnorm(1,0,tru.y.sig) #generate outcome
id[count] = i #patient identifier
period[count] = j
cyc[count] = 1 #cycle
t[count] = Trt[j]} #treatment
}
}
#generate posterior samples after initial patient data from 2 periods
current_data = list(J=J,N=N,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
Trt = c(0,1)
allocprob = matrix(0,nperiod-2,J) #array to store treatment allocation probabilities
#for each period
for (numpd in 3:nperiod){
for (pid in 1:J){
nsamp = dim(post_samples$beta1)[1] #check how many MCMC samples
indA = indB = 0
for (n in 1:nsamp){
y_expA = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[1]
y_expB = post_samples$beta1[n,pid] + post_samples$beta2[n,pid]*Trt[2]
if (y_expA < y_expB){indA = indA + 1} #indicator to check whether A or B is better
else {indB = indB + 1}                #lower y values implies lower pain score
}
wA = indA/nsamp #allocation probability
wB = indB/nsamp
c=0.5*(numpd/nperiod)   #tuning parameter
wA = (wA)^c/(wA^c + wB^c)
wB = 1- wA
allocprob[numpd-2,pid] = wA #keep track of allocation prob
t.next = sample(c(0,1), size=1, prob=c(wA,wB))  #treatment chosen based on allocations probs
#generate new observations for given patient based on chosen treatment
for (z in 1:nobv){
ynew = b[pid,1] + b[pid,2]*t.next + rnorm(1,0,tru.y.sig)
y = c(y,ynew)
id = c(id,pid)
period = c(period, numpd)
t = c(t, t.next)}
#posterior updating
nn = length(y)
current_data = list(J=J,N=nn,y=y,t=t,id=id)
hout = hmc_samples(current_data)
post_samples = extract(hout)
}
}
out <- list(allocprob,post_samples,hout,period,id,t,y)
return(out)
}
#indiv parameters
b0 = rnorm(J,tru.b.mu[1],tru.b.sig[1])
b1 = rnorm(J,tru.b.mu[2],tru.b.sig[2])
b = cbind(b0,b1)
trup = c(tru.b.mu,tru.b.sig,tru.y.sig,b0,b1)
set.seed(NULL) #undo seed setting
J = 3 #number of patients
nperiod = 4 #number of periods (two per cycle)
nobv = 2 #number of observations per patient
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
install.packages("RcppEigen")
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
remove.packages("StanHeaders")
install.packages("RcppParallel")
system.time({
out <- AGGBAN_run(J, nperiod, nobv, b, trup) #Aggregated Bayesian bandit adaptive design
})
setwd("H:/")
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars.win")
if (!file.exists(M)) file.create(M)
cat("\n CXX14FLAGS += -mtune=native -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2",
file = M, sep = "\n", append = FALSE)
devtools::install_version("StanHeaders", version="2.19.0")
Sys.getenv("BINPREF")
Sys.which("make")
install.packages("jsonlite", type = "source")
?install.packages
?install.packages
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
remove.packages("StanHeaders")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
setwd("H:/")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
install.packages("jsonlite", type = "source")
remove.packages("rstan")
remove.packages("StanHeaders")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install_cmdstan()
path.expand()
path.expand("~")
R.home(component="home")
14.4*33
1000/33
4*33
300*4
600*12
1/0.997
0.003/1
1/0.003
333*600000
150*13
150*10
1500*0.03
2350*65
2350*65*0.03
2350*65*0.03/17
system.time({
x <- curtailment::twoarmDesign(nmin.arm=32,
nmax.arm=64,
block.size=16,
pc=0.5,
pt=0.6,
alpha=0.05,
power=0.9,
maxthetaF=0.01,
minthetaE=0.99,
max.combns=100,
fast.method=TRUE)
})
system.time({
x <- curtailment::twoarmDesign(nmin.arm=32,
nmax.arm=64,
block.size=32,
pc=0.5,
pt=0.6,
alpha=0.05,
power=0.9,
maxthetaF=0.01,
minthetaE=0.99,
max.combns=100,
fast.method=TRUE)
})
system.time({
x <- curtailment::twoarmDesign(nmin.arm=20,
nmax.arm=40,
block.size=20,
pc=0.5,
pt=0.6,
alpha=0.05,
power=0.9,
maxthetaF=0.01,
minthetaE=0.99,
max.combns=100,
fast.method=TRUE)
})
x
stage_2
library(MAMS)
pc_1=0.5 #Probability under control that the patient does not get better
pc_2=0.5 #Probability under control that the patient does get better
pIe_1=0.4 #Probability under interesting effect that the patient does not get better
pIe_2=0.6 #Probability under interesting effect that the patient does get better
pUe_1=0.49 #Probability under uninteresting effect that the patient does not get better
pUe_2=0.51  #Probability under uninteresting effect that the patient does not get better
or_I=(pIe_2*pc_1)/(pIe_1*pc_2) #odds ratio for interesting
or_I
or_U=(pUe_2*pc_1)/(pUe_1*pc_2) #odds ratio for UNinteresting
or_U
library(MAMS)
stage_1=ordinal.mams(prob=c(pc_1,pc_2), or=or_I, or0=or_U, K=1, J=1, alpha=0.05,
power=0.9, r=1, r0=1, ushape="triangular",
lshape="triangular")
stage_1
stage_2=ordinal.mams(prob=c(pc_1,pc_2), or=or_I, or0=or_U, K=1, J=2, alpha=0.05,
power=0.9, r=1:2, r0=1:2, ushape="triangular",
lshape="triangular")
stage_2
stage_3=ordinal.mams(prob=c(pc_1,pc_2), or=or_I, or0=or_U, K=1, J=3, alpha=0.05,
power=0.9, r=1:3, r0=1:3, ushape="triangular",
lshape="triangular") #also add for shapes obf0
stage_3
setwd("~/R_packages/curtailment/R")
xx <- scriptSearch("which.min", subdirs=TRUE, commentsIncluded=F, verbose = T)
library(BurStMisc)
xx <- scriptSearch("which.min", subdirs=TRUE, commentsIncluded=F, verbose = T)
xx
setwd("..")
getwd()
xx <- scriptSearch("which.min", subdirs=TRUE, commentsIncluded=F, verbose = T)
xx
xx <- scriptSearch("which.max", subdirs=TRUE, commentsIncluded=F, verbose = T)
xx
devtools::document()
warnings()
devtools::document()
warnings()
getwd()
xx <- BurStMisc::scriptSearch("import data", subdirs=TRUE, commentsIncluded=T, verbose = T)
xx
devtools::document()
("data.table")
usethis::use_package("data.table")
devtools::document()
roxygen2::roxygenise()
devtools::document()
